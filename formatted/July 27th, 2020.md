- 上午下雨了,[老婆](<老婆.md>),[我爸](<我爸.md>),[我妈](<我妈.md>),我们一起陪[李一诺](<李一诺.md>)去玩.上午去了[西小口公园](<西小口公园.md>),下午去[五彩城](<五彩城.md>)玩了.晚上在五彩城的[云海肴](<云海肴.md>)吃的饭.
- [李一诺](<李一诺.md>)的拉拉裤到了,京东快递直接放在门口了
- 可能是昨天比较累,晚上做了很多梦,梦见自己从车上跑下来,后来又各种破案的情节
- {[x] }} 倚天外部员工接口添加工号,需要对接
- {[x] }} Q2[绩效考核](<绩效考核.md>)[自评](<自评.md>)完成
- [JMM](<JMM.md>)提供了一个保证内存可见性的原则：happens-before原则
- [volatile](<volatile.md>)和[synchronized](<synchronized.md>)区别
    - 首先需要理解[线程](<线程.md>)安全的两个方面：[执行控制](<执行控制.md>)和[内存可见](<内存可见.md>)
        - 内存可见控制的是[线程](<线程.md>)执行结果在内存中对其它[线程](<线程.md>)的可见性
    - [synchronized](<synchronized.md>)还会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的[线程](<线程.md>)的所有操作，都[happens-before](<happens-before.md>)于随后获得这个锁的[线程](<线程.md>)的操作。
    - [volatile](<volatile.md>)关键字解决的是内存可见性的问题，会使得所有对volatile变量的读写都会直接刷到主存，即保证了变量的可见性。这样就能满足一些对变量可见性有要求而对读取顺序没有要求的需求。
    - volatile不能保证复合操作的原子性，即使只是i++，实际上也是由多个原子操作组成
    - 对于volatile关键字，当且仅当满足以下所有条件时可使用：
        - volatile本质是在告诉jvm当前变量在[寄存器](<寄存器.md>)（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前[线程](<线程.md>)可以访问该变量，其他[线程](<线程.md>)被阻塞住。
        - volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
        - volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
        - volatile不会造成[线程](<线程.md>)的阻塞；synchronized可能会造成[线程](<线程.md>)的阻塞。
        - volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化
- [JVM](<JVM.md>)
- [RoamEdit](<RoamEdit.md>)今天登陆还是有问题,尝试了好几次之后,我把数据都转移到[Roam Research](<Roam Research.md>)中了

# Backlinks
## [July 24th, 2020](<July 24th, 2020.md>)
- {[x] }} 给[胡莹莹](<胡莹莹.md>)客户名称匹配客户编号[July 27th, 2020](<July 27th, 2020.md>)

- {[x] }} 和[鲁栋鹏](<鲁栋鹏.md>)一起调试关联项目绑定客户编码接口[July 27th, 2020](<July 27th, 2020.md>)

