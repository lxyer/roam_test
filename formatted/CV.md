- # [KN](<KN.md>)
    - ## JVM问题
        - CPU过高问题排查
            - top -p 5578（Java进程号）
            - Shit+h显示所有的线程CPU统计（有PID）
            - jstack -F PID 打印线程堆栈信息
        - OOM问题
            - jstat -gcutil PID 查看堆空间的占用情况，分析一下
            - heapdump xx.hprof 把堆栈信息导入到文件中
            - 下载到本地
            - VisualVM
                - File->load 分析
                - 查看Instance的数量排行
                - 选择一个类点击右键->open in new tap
                - 点击GC Root可以显示调用栈的调用轨迹定位到oss客户端的run方法
                - 在OSSUtil工具类中，使用完需要调用ossClient.shutDown()方法
        - ## 垃圾回收器
            - [七种垃圾收集器的对比总结](https://blog.csdn.net/Sylvia_17/article/details/102085290)
            - [垃圾收集的四种算法（标记-清除、复制算法、标记-整理、分代收集）总结](https://blog.csdn.net/Sylvia_17/article/details/101997296)
            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Flxyer%2FFqGYp-Uyy0.png?alt=media&token=c47422cc-51f6-46a4-961a-260d52778a75)
            - ## JVM优化之G1垃圾收集器如何做到可预测停顿的
                - G1优化的步骤中有一个步骤是让使用者自行设置暂停应用的时间，为啥能够做到这一点，G1回收的第4步【G1垃圾收集基础】，它是“选择一些内存块”，而不是整代内存来回收，其它GC每次回收都会回收整个内存(Eden, Old), 回收内存所需的时间取决于内存的大小，以及实际垃圾的多少，所以垃圾回收时间是不可控的；而G1每次并不会回收整代内存，到底回收多少内存就看用户配置的暂停时间，配置的时间短就少回收点相反就多回收点,G1垃圾收集器的G1其实是Garbage First的意思，这里并不是垃圾优先 的意思，而是优先处理那些垃圾多的内存块的意思。
                - 参数优化
                    - XX:MaxGCPauseMillis：设置允许的最大GC停顿时间(GC pause time)，这只是一个期望值，实际可能会超出，可以和年轻代大小调整一起并用来实现。默认是200ms。
                    - XX:G1HeapRegionSize：每个分区的大小，默认值是会根据整个堆区的大小计算出来，范围是1M~32M，取值是2的幂，计算的倾向是尽量有2048个分区数。比如如果是2G的heap，那region=1M。16Gheap,region=8M。
                    - XX:MaxTenuringThreshold=n：晋升到老年代的“年龄”阀值，默认值为 15。
                    - XX:InitiatingHeapOccupancyPercent：一般会简写IHOP,默认是45%,这个占比跟并发周期的启动相关，当空间占比达到这个值时，会启动并发周期。如果经常出现FullGC，可以调低该值，尽早的回收可以减少FullGC的触发，但如果过低，则并发阶段会更加频繁，降低应用的吞吐。
                    - XX:G1NewSizePercent：年轻代最小的堆空间占比，默认是5%。
                    - XX:G1MaxNewSizePercent：年轻代最大的堆空间占比，默认是60%。
                    - XX:ConcGCThreads：并发执行的线程数，默认值接近整个应用线程数的1/4。
                    - XX:-XX:G1HeapWastePercent:允许的浪费堆空间的占比，默认是5%。如果并发标记可回收的空间小于5%,则不会触发MixedGC。
                    - XX:G1MixedGCCountTarget:一次全局并发标记之后，后续最多执行的MixedGC次数。 默认值是8.
            - [ZGC](<ZGC.md>)(Z Garbage Collector)作为一种比较新的收集器。作为一款低延迟的垃圾收集器，它有如下几个亮点:
                - 停顿时间不会超过 10ms
                - 停顿时间不会随着堆的增大而增大（控制停顿时间在 10ms 内）
                - 支持堆的大小范围很广（8MB-16TB）
                - 在 ZGC 中，连逻辑上的也是重新定义了堆空间（不区分年轻代和老年代），只分为一块块的 page，每次进行 GC 时，都会对 page 进行压缩操作，所以没有碎片问题。ZGC 只在特定情况下具有绝对的优势, 如巨大的堆和极低的暂停需求。也有一种观点认为 ZGC 是为大内存、多 cpu 而生，它通过分区的思路来降低 STW。
                - ZGC 在 JDK14 前只支持 Linux, 从 JDK14 开始支持 Mac 和 Windows。
                - 与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。
            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Flxyer%2FgUGb8HLndW.png?alt=media&token=93a70c62-1937-4d5d-88d9-6e2821a03587)
            - [线程](<线程.md>)共享
                - [堆](<堆.md>)（Heap）：[线程](<线程.md>)共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。
                - [方法区](<方法区.md>)（Method Area）：[线程](<线程.md>)共享。存储类信息、常量、静态变量、即时编译器编译后的代码。
            - [线程](<线程.md>)私有
                - [方法栈](<方法栈.md>)（JVM Stack）：[线程](<线程.md>)私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。
                - [本地方法栈](<本地方法栈.md>)（Native Method Stack）：[线程](<线程.md>)私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。
                - [程序计数器](<程序计数器.md>)（Program Counter Register）：[线程](<线程.md>)私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前[线程](<线程.md>)所执行的字节码的行号指示器。指向下一条要执行的指令。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。
        - ## [Synchronized](<Synchronized.md>)
        - ## [Java内存模型](<Java内存模型.md>)
            - ![](https://pic4.zhimg.com/80/v2-b098a84eb7598d70913444a991d1759b_720w.jpg)
            - 
        - [Java9/Java10/Java11的新特性](https://www.cnblogs.com/laizhenghua/articles/13211557.html)
            - JDK9 主要新特性一览
                - JDK9模块化系统
                    - 本质上讲也就是说，用模块来管理各个package，通过声明某个package 暴露，**模块(module)的概念，其实就是package外再裹一层**，不声明默 认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪 些部分可以暴露，哪些部分隐藏。
                -  jShell命令
                    - 让**Java**可以像脚本语言一样运行，从 控制台启动**jShell**，利用**jShell**在没有创建类的情况下直接声明变量，计算表达式， 执行语句。
                - 可以实现资源的自动关闭，但是要求执行后必须关闭的所有资源必 须在try子句中初始化，否则编译不通过
                - JDK9 String存储结构变更
                    - 在以前的版本中，String一直是用char[]存储，但是在Java9中，String 再也不用 char[] 来存储啦，改成了 byte[] 加上编码标记，节约 了一些空间
                -  集合工厂方法：快速创建只读集合
                - Stream API的加强
                    - Stream 接口中添加了 **4 个新的方法： takeWhile, dropWhile, ofNullable，还有个 iterate 方法的新重载方法**
                - Javascript引擎升级：Nashorn
            - JDK10 主要新特性一览
                - 局部变量类型推断
                - 集合新增创建不可变集合的方法
            - JDK11 新特性
                - 新增了一系列字符串处理方法
                - **Optional** 也增加了几个非常酷的方法，现在可以很方便的将一个 **Optional** 转换 成一个 **Stream**, 或者当一个空 **Optional** 时给它一个替代的
                - 局部变量类型推断升级
                - HttpClient替换原有的HttpURLConnection
        - [淘宝一面：“说一下 Spring Boot 自动装配原理呗？”](https://www.cnblogs.com/javaguide/p/springboot-auto-config.html)
        - [Java 类加载器（ClassLoader）的实际使用场景有哪些？](https://www.zhihu.com/question/46719811/answer/1739289578)
            - 加载
                - 加载就是将class文件载入jvm中
            - 验证
                - 主要校验载入的class是否符合jvm规范。
                    - 比如魔数校验，是否以魔数0xCAFEBABE开头
                    - 版本号校验，主、次版本号是否在当前虚拟机处理范围之内
                    - 逻辑验证
                    - 常量池的常量中是否有不被支持的常量类型
                    - 确定程序语义是否合法
                    - 这个类的父类是否继承了不允许被继承的类（被final修饰的类）
            - 准备
                - 为类变量分片内存并给类变量设置初始值
            - 解析
                - 这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用
            - 初始化
            - 使用
            - 卸载
            - [双亲委派](<双亲委派.md>)保证类加载器，自下而上的委派，又自上而下的加载，保证每一个类在各个类加载器中都是同一个类。
        - jvm内存泄露问题和分析解决过程
            - 通过指令：jstat -gcutil 查看jvm内存占用和gc情况
            - 使用指令：jmap -histo:live *** | more 查看堆内存中的对象数量和大小
            - 在前一步分析内存的同时，使用指令：jmap -dump:format=b,file=heapDump.hprof将实时内存信息导出（dump过程比较慢，所以在问题暂时处理完后进行后续分析），使用mat分析内存结构
            - 使用指令：jmap -histo:live  查看堆内存中的对象数量和大小
    - ## Java基础
        - [HashMap](<HashMap.md>)
    - # [Redis](<Redis.md>)
        - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Flxyer%2FE4AHUcUDZp.png?alt=media&token=785f163d-47e6-416b-9fb9-79c0e0c93386)
        - [集群](<集群.md>)方案
            - [主从复制模式](<主从复制模式.md>)
                - ![Redis-master-slave](https://image-static.segmentfault.com/124/529/1245298177-5e6ed603a6d8b_articlex)
                - 具体工作机制为：
                    - slave启动后，向master发送SYNC命令，master接收到SYNC命令后通过[bgsave](<bgsave.md>)保存快照（即上文所介绍的RDB持久化），并使用缓冲区记录保存快照这段时间内执行的写命令
                    - master将保存的快照文件发送给slave，并继续记录执行的写命令
                    - slave接收到快照文件后，加载快照文件，载入数据
                    - master快照发送完后开始向slave发送缓冲区的写命令，slave接收命令并执行，完成复制初始化
                    - 此后master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性
                - 优点：
                    - master能自动将数据同步到slave，可以进行读写分离，分担master的读压力
                    - master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求
                - 缺点：
                    - 不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复
                    - master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题
                    - 难以支持在线扩容，[Redis](<Redis.md>)的容量受限于单机配置
            - [Sentinel](<Sentinel.md>)（哨兵）模式
                - 哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障
                - ![Redis-sentinel](https://image-static.segmentfault.com/423/790/4237905659-5e6ed60450b11_articlex)
                - 哨兵的功能：
                    - 监控master、slave是否正常运行
                    - 当master出现故障时，能自动将一个slave转换为master（大哥挂了，选一个小弟上位）
                    - 多个哨兵可以监控同一个[Redis](<Redis.md>)，哨兵之间也会自动监控
                - 哨兵认为master客观下线后，故障恢复的操作需要由选举的领头哨兵来执行，选举采用[Raft](<Raft.md>)算法：
                    - 发现master下线的哨兵节点（我们称他为A）向每个哨兵发送命令，要求对方选自己为领头哨兵
                    - 如果目标哨兵节点没有选过其他人，则会同意选举A为领头哨兵
                    - 如果有超过一半的哨兵同意选举A为领头，则A当选
                    - 如果有多个哨兵节点同时参选领头，此时有可能存在一轮投票无竞选者胜出，此时每个参选的节点等待一个随机时间后再次发起参选请求，进行下一轮投票竞选，直至选举出领头哨兵
                - 选出领头哨兵后，领头者开始对系统进行故障恢复，从出现故障的master的从数据库中挑选一个来当选新的master,选择规则如下：
                    - 所有在线的slave中选择优先级最高的，优先级可以通过slave-priority配置
                    - 如果有多个最高优先级的slave，则选取复制偏移量最大（即复制越完整）的当选
                    - 如果以上条件都一样，选取id最小的slave
                - 挑选出需要继任的slave后，领头哨兵向该数据库发送命令使其升格为master，然后再向其他slave发送命令接受新的master，最后更新数据。将已经停止的旧的master更新为新的master的从数据库，使其恢复服务后以slave的身份继续运行。
                - 优点：
                    - 哨兵模式基于[主从复制模式](<主从复制模式.md>)，所以主从复制模式有的优点，哨兵模式也有
                    - 哨兵模式下，master挂掉可以自动进行切换，系统可用性更高
                - 缺点：
                    - 同样也继承了主从模式难以在线扩容的缺点，[Redis](<Redis.md>)的容量受限于单机配置
                    - 需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务
            - [Cluster模式](<Cluster模式.md>)
                - 哨兵模式解决了主从复制不能自动故障转移，达不到高可用的问题，但还是存在难以在线扩容，[Redis](<Redis.md>)容量受限于单机配置的问题。Cluster模式实现了[Redis](<Redis.md>)的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题
                - Cluster采用无中心结构,它的特点如下：
                    - 所有的[Redis](<Redis.md>)节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽
                    - 节点的fail是通过集群中超过半数的节点检测失效时才生效
                    - 客户端与[Redis](<Redis.md>)节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可
                - Cluster模式的具体工作机制：
                    - 在[Redis](<Redis.md>)的每个节点上，都有一个插槽（slot），取值范围为0-16383
                    - 当我们存取key的时候，[Redis](<Redis.md>)会根据CRC16的算法得出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作
                    - 为了保证高可用，Cluster模式也引入主从复制模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点
                    - 当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了
                - Cluster模式集群节点最小配置6个节点(3主3从，因为需要半数以上)，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。
    - ## [MySQL](<MySQL.md>)
        - explain 的type类型（性能排序）
            - system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略不计
            - const：表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const
            - eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描。
            - **ref**：非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体。
            - **range**：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了那个索引。一般就是在 where 语句中出现了 bettween、<、>、in 等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引。
            - **index**：Full Index Scan，index 与 ALL 区别为 index 类型只遍历索引树。这通常为 ALL 块，应为索引文件通常比数据文件小。（Index 与 ALL 虽然都是读全表，但 index 是从索引中读取，而 ALL 是从硬盘读取）
            - ALL：Full Table Scan，遍历全表以找到匹配的行
        - [项目中常用的19条MySQL优化](https://segmentfault.com/a/1190000012155267)
            - 善用 **EXPLAIN** 查看SQL执行计划
            - SQL语句中IN包含的值不应过多
            - SELECT语句务必指明字段名称
            - 表中有大字段需要拆子表
            - 当只需要一条数据的时候，使用limit 1
            - 如果排序字段没有用到索引，就尽量少排序
            - 如果限制条件中其他字段没有索引，尽量少用or
            - 尽量用union all代替union
            - 使用合理的分页方式以提高分页的效率
            - 分段查询
            - 避免在 where 子句中对字段进行 null 值判断
            - 不建议使用%前缀模糊查询，如需要使用全文索引
            - 避免在where子句中对字段进行表达式操作
            - 避免隐式类型转换
            - 对于联合索引来说，要遵守最左前缀法则
            - 必要时可以使用force index来强制查询走某个索引
            - 利用小表去驱动大表
        - [MVCC](<MVCC.md>)
        - [互联网项目中mysql应该选什么事务隔离级别](https://cloud.tencent.com/developer/article/1431607)
    - ## 缓存
        - [Redis](<Redis.md>)与[Memcached](<Memcached.md>)的区别
            - [Redis](<Redis.md>)不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
            - [Redis](<Redis.md>)支持数据的备份，即master-slave模式的数据备份。
            - [Redis](<Redis.md>)支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。
            - [Redis](<Redis.md>)中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别。[Redis](<Redis.md>)只会缓存所有的 key的信息，如果[Redis](<Redis.md>)发现内存的使用量超过了某一个阀值，将触发swap的操作，[Redis](<Redis.md>)根据“swappability = age*log(size_in_memory)”计 算出哪些key对应的value需要swap到磁盘。然后再将这些key对应的value持久化到磁盘中，同时在内存中清除。这种特性使得[Redis](<Redis.md>)可以 保持超过其机器本身内存大小的数据。
            - Memcached是多[线程](<线程.md>)，非阻塞IO复用的网络模型
            - Memcached提供了cas命令，可以保证多个并发访问操作同一份数据的一致性问题。 [Redis](<Redis.md>)没有提供cas 命令，并不能保证这点，不过[Redis](<Redis.md>)提供了事务的功能，可以保证一串 命令的原子性，中间不会被任何操作打断。
            - Memcached通过使用多个内核实现多[线程](<线程.md>)体系结构。 因此，对于存储更大的数据集，Memcached的性能要优于[Redis](<Redis.md>)。[Redis](<Redis.md>)使用单核，在存储小数据集方面表现出比 Memcached 更好的性能。
            - memcached对key和value的限制：最大键长为250个字符。可以接受的储存数据不能超过1MB(可以通过修改源码进行配置，但是太大之后会报警告)
            - [Redis](<Redis.md>)各个类型的value值的最大容量
                - Stringvalue最大可以存储512M
                - hash键值对个数最多为2^32-1个，即4294967295个
                - List元素个数最多为2^32-1个，即4294967295个
                - Set元素个数最多为2^32-1个，即4294967295个
                - SortSet元素个数最多为2^32-1个，即4294967295个
            - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Flxyer%2Fv8VztIa6vN.png?alt=media&token=442eaf38-85ac-48a5-8afa-0c2a0943084b)
    - ### [【面试】迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章（快快珍藏）](https://www.cnblogs.com/lixinjie/p/a-post-about-io-clearly.html)
    - ## [IO](<IO.md>)
    - ## [CAS原理](<CAS原理.md>)及解决[ABA问题](<ABA问题.md>)
    - ## [布隆过滤器](<布隆过滤器.md>)
    - ## [Spring](<Spring.md>)
    - ## [微服务](<微服务.md>)
    - ## [Nginx](<Nginx.md>)
    - ## [并发编程](<并发编程.md>)-[JUC](<JUC.md>)
    - ## [高可用](<高可用.md>)
    - ## [微服务划分](<微服务划分.md>)
    - ## [MQ](<MQ.md>)
- ## Other
    - 找工作，本质是你的实力与公司福利的博弈。你的实力越强，公司福利越低，你的概率就越大。而且找工作应该心平气和，应该以合作者的角度去做，而不是对抗的面试角度。先和公司沟通一下，了解公司是做啥业务，最近在做什么项目，缺啥岗位，有什么要求，制度是什么，福利怎样。然后自己想想能给公司创造什么价值，是否能接受对方公司的福利与制度。如果能接受，把自己做过的东西，给对方看看，谈谈自己在相关领域的想法，谈谈自己入职后的打算与安排。最后，也别想着一定能成，就算你有秒天秒地的能力，但也有可能因为一些别的奇葩原因而被拒，很正常的。这玩意有点像找女朋友，别贪，然后广散网就对了。失败几次没啥。
    - 

# Backlinks
## [August 10th, 2021](<August 10th, 2021.md>)
- [CV](<CV.md>)

