- ____ — via [Java Synchronized 偏向锁/轻量级锁/重量级锁的演变过程 - 掘金](https://juejin.cn/post/7007656138518822925) [+Roam](<+Roam.md>)
    - t2因为没有获取到锁然后挂起自己，等待t1释放锁后唤醒自己。线程的挂起/唤醒需要CPU切换上下文，此过程代价比较大，因此称此种锁为重量级锁。
    - 假设现在t1、t2是交替执行testLock()方法，此时t1、t2没必要阻塞，因为它们之间没有竞争，也就是不需要重量级锁。 线程之间交替执行临界区的情形下使用的锁称为轻量级锁。
    - 轻量级锁相比重量级锁的优势：
        - 1、每次加锁只需要一次CAS
        - 2、不需要分配ObjectMonitor对象
        - 3、线程无需挂起与唤醒
    - 当锁偏向某个线程时，该线程再次获取锁时无需CAS，只需要一个简单的比较就可以获取锁，这个过程效率很高。
    - 偏向锁相比轻量级锁的优势：
        - 同一个线程多次获取锁时，无需再次进行CAS，只需要简单比较。
    - 1、先判断Mark Word里的线程id是否有值。
        - 1.1、如果没有，说明还没有线程占用锁，则直接将t1的线程id记录到Mark Word里。可能会存在多个线程同时修改>Mark Word，因此需要进行CAS修改Mark Word。
        - 1.2、如果已有id值，那么判断分两种情况：
            - 1.2.1、该id是t1的id，则此次获取锁是个重入的过程，直接就获取了。
            - 1.2.2、如果该id不是t1的id，说明已经有其它线程获取了锁，t1想要获取锁就需要走撤销流程。
- 锁状态一种有四种，从级别由低到高依次是：无锁、偏向锁，轻量级锁，重量级锁，锁状态只能升级，不能降级
    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Flxyer%2Fkyu6VuaoMn.png?alt=media&token=c2f5362c-ef64-440f-8197-7757eb3102ab)
- 锁粗化:锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。
- 锁消除:通过对运行上下文的扫描，经过逃逸分析，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间

# Backlinks
## [CV](<CV.md>)
- ## [Synchronized](<Synchronized.md>)

