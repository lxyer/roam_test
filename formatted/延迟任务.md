- [延迟任务](<延迟任务.md>)的使用场景
    - 红包24小时未查收,金额进行退还
    - 每个月的账单日,给用户发送账单
    - 订单下单后30分钟没有支付,系统自动取消订单
- [延迟任务](<延迟任务.md>)和[定时任务](<定时任务.md>)的区别
    - [延迟任务](<延迟任务.md>)不需要对一个任务使用短时间间隔的定时任务不同的去执行,到了需要执行的时间执行一次即可
- 实现思路
    - [JDK](<JDK.md>)实现
        - [DelayQueue](<DelayQueue.md>)
        - [ScheduledExecutorService](<ScheduledExecutorService.md>)
    - 第三方工具的[延迟任务](<延迟任务.md>)
        - [Redis](<Redis.md>)
            - 借助 [zset](<zset.md>) 数据类型，把[延迟任务](<延迟任务.md>)存储在此数据集合中，然后在开启一个无线循环查询当前时间的所有任务进行消费
            -  [Redis ](<Redis .md>)服务器端是不开启键空间通知的，需要我们通过 config set notify-keyspace-events Ex 的命令手动开启，开启键空间通知后，我们就可以拿到每个键值过期的事件，我们利用这个机制实现了给每个人开启一个定时任务的功能
        - [Netty](<Netty.md>)
            - 工具类 [HashedWheelTimer ](<HashedWheelTimer .md>)来实现[延迟任务](<延迟任务.md>)
                - HashedWheelTimer 是使用定时轮实现的，[定时轮](<定时轮.md>)其实就是一种环型的数据结构
        - [MQ](<MQ.md>)
            - [RabbitMQ](<RabbitMQ.md>)
                - 通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能
                - 使用 [RabbitMQ](<RabbitMQ.md>)-delayed-message-exchange 插件实现延迟功能
    - 无限循环实现[延迟任务](<延迟任务.md>)
        - 使用一个map储存定时任务名称和需要执行的时间戳
        - 用一个死循环去判断需要执行的时间戳是否小于当前时间的时间戳,是的话执行任务
        - map中remove这个任务
    - 使用[Spring](<Spring.md>)[定时任务](<定时任务.md>)
    - [Quartz ](<Quartz .md>)实现[延迟任务](<延迟任务.md>)
- 总结
    - 手动无线循环；
    - ScheduledExecutorService；
    - DelayQueue；
    - Redis zset 数据判断的方式；
    - Redis 键空间通知的方式；
    - Netty 提供的 HashedWheelTimer 工具类；
    - RabbitMQ 死信队列；
    - RabbitMQ 延迟消息插件 rabbitmq-delayed-message-exchange；
    - Spring Scheduled；
    - Quartz。

# Backlinks
## [July 22nd, 2020](<July 22nd, 2020.md>)
- [延迟任务](<延迟任务.md>)

## [延迟任务](<延迟任务.md>)
- [延迟任务](<延迟任务.md>)的

- [延迟任务](<延迟任务.md>)和

- [延迟任务](<延迟任务.md>)不

- 第三方工具的[延迟任务](<延迟任务.md>)

- 借助 [zset](<zset.md>) 数据类型，把[延迟任务](<延迟任务.md>)存

- 工具类 [HashedWheelTimer ](<HashedWheelTimer .md>)来实现[延迟任务](<延迟任务.md>)

- 无限循环实现[延迟任务](<延迟任务.md>)

- [Quartz ](<Quartz .md>)实现[延迟任务](<延迟任务.md>)

