- Redis开发与运维  [📖](marginnote3app://note/83884509-CF80-479C-969C-1A1FB2E279EA)
    - 对本书的赞誉 [📖](marginnote3app://note/82395DE8-94C6-4C2A-8AB9-221E7F70F123)
    - 序言 [📖](marginnote3app://note/44E7087F-BAA8-4E16-93D3-AD4A30B4A7BC)
    - 前言 [📖](marginnote3app://note/5CBE59EF-094D-4DB9-8DD5-A592F1EA027E)
    - 致谢 [📖](marginnote3app://note/951A1E22-675B-45D0-AE68-78F6390C9577)
    - 第1章 初识Redis [📖](marginnote3app://note/A860D263-395E-4F39-823C-D883740904F0)
        - 1.1 盛赞Redis [📖](marginnote3app://note/16B5A2D0-4880-4484-BDCB-FAA026C4EFDE)
            - Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上 [📖](marginnote3app://note/C984CEB1-E606-411D-824A-AB542DE0ACC5)
        - 1.2 Redis特性 [📖](marginnote3app://note/0FA4FCC5-3BC3-41C8-8235-91672F34BE39)
            - 速度快 [📖](marginnote3app://note/45224B67-A63B-4410-8228-2EB9BC90D270)
                - Redis的所有数据都是存放在内存中的 [📖](marginnote3app://note/387ADC0E-952D-4BF9-A683-7F2F69DB6F7B)
                - ·Redis是用C语言实现的,一般来说C语言实现的程序“距离”操作系统更近,执行速度相对会更快。 [📖](marginnote3app://note/79C19139-3035-47DE-93FB-DE1EF6159094)
                - ·Redis使用了单线程架构,预防了多线程可能产生的竞争问题。 [📖](marginnote3app://note/C0F19E5E-E3AE-4778-B42E-2CFFDF6AD467)
                - Redis是少有的集性能和优雅于一身的开源代码 [📖](marginnote3app://note/02ACF07C-BD90-4AC7-B790-BF01E2FE4EEA)
        - 1.3 Redis使用场景 [📖](marginnote3app://note/80C923C4-A364-4C1E-8C8C-5CEA6C88A737)
            - 1.3.1 Redis可以做什么 [📖](marginnote3app://note/E880B6DA-B875-416D-8570-428126E7C030)
            - 1.3.2 Redis不可以做什么 [📖](marginnote3app://note/2B2651F6-3096-4608-8478-5662335DBFAA)
        - 1.4 用好Redis的建议 [📖](marginnote3app://note/39A54DAB-20D8-4BE7-B5D8-EAB111DF10B0)
        - 1.5 正确安装并启动Redis [📖](marginnote3app://note/973FBFE1-6F8F-4473-BE36-E344222DA859)
            - 1.5.1 安装Redis [📖](marginnote3app://note/CDBC9310-7CA4-45A7-B5ED-DE795EA3D6AA)
            - 1.5.2 配置、启动、操作、关闭Redis [📖](marginnote3app://note/9E1205C2-8CB6-4F65-84F4-387EC2613B79)
        - 1.6 Redis重大版本 [📖](marginnote3app://note/0A05AD98-66D2-4793-8013-231926296741)
        - 1.7 本章重点回顾 [📖](marginnote3app://note/240EC3AE-0E30-448A-ADC7-DA57B978242E)
    - 第2章 API的理解和使用 [📖](marginnote3app://note/88B97AC1-FDA9-41EE-9024-420BE8012289)
        - 2.1 预备 [📖](marginnote3app://note/B81758E5-A240-4B5E-8D7B-E71B818FAFA7)
            - 2.1.1 全局命令 [📖](marginnote3app://note/F50F5D01-9D82-4746-B07B-F1A5E0A0535D)
                - dbsize命令会返回当前数据库中键的总数 [📖](marginnote3app://note/63FCAE98-66E8-416B-84EC-EC190308D879)
                - dbsize命令在计算键总数时不会遍历所有键,而是直接获取Redis内置的键总数变量,所以dbsize命令的时间复杂度是O(1) [📖](marginnote3app://note/754D35DC-DFD1-4836-906C-0B24E608DA02)
                - keys命令会遍历所有键,所以它的时间复杂度是O(n) [📖](marginnote3app://note/885576AB-80C6-45A0-897B-B319169CF1F4)
                - ttl命令会返回键的剩余过期时间 [📖](marginnote3app://note/48CF8B46-6FFF-440F-AE93-C48E33095F38)
            - 2.1.2 数据结构和内部编码 [📖](marginnote3app://note/E3B933BB-3571-458F-97A6-DEEE95EC8C96)
            - 2.1.3 单线程架构 [📖](marginnote3app://note/571A90E6-D704-4070-8744-1CD67F8ED671)
                - Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务 [📖](marginnote3app://note/FE6961C3-558A-42EC-965D-C80D65B8E40B)
                - 为什么单线程还能这么快 [📖](marginnote3app://note/FCD6AD17-CCF9-4160-9B00-F075A75F360A)
                    - 第一,纯内存访问,Redis将所有数据放在内存中,内存的响应时长大约为100纳秒,这是Redis达到每秒万级别访问的重要基础。 [📖](marginnote3app://note/6AA80D2B-8F48-4D6D-9242-7FF2C1074DA4)
                    - 第二,非阻塞I/O,Redis使用epoll作为I/O多路复用技术的实现,再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件,不在网络I/O上浪费过多的时间 [📖](marginnote3app://note/85F127B4-9FC8-40D5-9026-C70BBB5FA34F)
                    - 第三,单线程避免了线程切换和竞态产生的消耗。 [📖](marginnote3app://note/FA609C77-DCB2-4809-A4B7-7453F6F937A1)
        - 2.2 字符串 [📖](marginnote3app://note/6FB6E2A6-10F4-44FD-9FE0-2B6CBD87F680)
            - 2.2.1 命令 [📖](marginnote3app://note/BCFEEA7D-10C7-4101-87F9-41430679946A)
                - ·ex seconds:为键设置秒级过期时间。 [📖](marginnote3app://note/E5BD2679-5FD4-4C13-BA5C-F634171E5684)
                - ·px milliseconds:为键设置毫秒级过期时间。 [📖](marginnote3app://note/4450FB10-493C-44FD-AF6B-FE5BFB49700E)
                - ·nx:键必须不存在,才可以设置成功,用于添加。 [📖](marginnote3app://note/95F3AC04-F6C5-4F76-BC35-678AE95E4276)
                - ·xx:与nx相反,键必须存在,才可以设置成功,用于更新。 [📖](marginnote3app://note/CD691B40-278E-4991-9B0F-F19BCDDD18DD)
            - 2.2.2 内部编码 [📖](marginnote3app://note/371DFF1A-219E-4546-B5DE-B8EC12F0D35A)
            - 2.2.3 典型使用场景 [📖](marginnote3app://note/D55A1D61-22AD-4E1A-87E7-E50691C529C1)
            - Redis中字符串类型的值最大不能超过512MB。 [📖](marginnote3app://note/2FE326F3-48C6-4388-B051-B160DF258994)
        - 2.3 哈希 [📖](marginnote3app://note/E5DF7202-2C9B-44C6-8CF6-CA2E9FE77585)
            - 2.3.1 命令 [📖](marginnote3app://note/C6C4BD75-EF74-4476-9246-DB591F45A97A)
            - 2.3.2 内部编码 [📖](marginnote3app://note/2DBA7405-3843-499D-9038-410464B75221)
            - 2.3.3 使用场景 [📖](marginnote3app://note/468EDCC0-B716-4ACA-8C1A-D907516B0269)
        - 2.4 列表 [📖](marginnote3app://note/BC3F5689-F654-4AD3-898B-EE6C2F8B0DA7)
            - 2.4.1 命令 [📖](marginnote3app://note/AA89FD5B-72E3-4704-A83E-269235D881CB)
                - ,如果是多个键,那么brpop会从左至右遍历键,一旦有一个键能弹出元素,客户端立即返回 [📖](marginnote3app://note/080304BE-45C7-4525-9EEC-F8BE0CEB4FE4)
            - 2.4.2 内部编码 [📖](marginnote3app://note/16A70818-55CA-441D-874E-1EFF2B2D76B4)
            - 2.4.3 使用场景 [📖](marginnote3app://note/A3F09AD2-D257-40E1-9BF5-60FA0BF2BCC8)
        - 2.5 集合 [📖](marginnote3app://note/0C0B78DA-07ED-437E-BECE-6E0AAC629438)
            - 2.5.1 命令 [📖](marginnote3app://note/76578A71-16DA-47CE-8D06-93B9D80C8774)
            - 2.5.2 内部编码 [📖](marginnote3app://note/51A62876-DF81-4039-879B-EBB6D847B95C)
            - 2.5.3 使用场景 [📖](marginnote3app://note/46CEEAE9-19B0-4F9E-ADDA-C47B0B68BA5D)
        - 2.6 有序集合 [📖](marginnote3app://note/2C5477D2-4112-4C55-8D9C-5CEC39DFC723)
            - 2.6.1 命令 [📖](marginnote3app://note/50DCB4BF-85ED-40E2-BB35-E9A6CFC8632D)
            - 2.6.2 内部编码 [📖](marginnote3app://note/1C1DBAD9-9803-4C86-9CDD-F45192B0E149)
            - 2.6.3 使用场景 [📖](marginnote3app://note/FA273D25-5C9A-4F0A-A541-3FA54E8D49A7)
        - 2.7 键管理 [📖](marginnote3app://note/605855FE-D358-4BC4-ACBB-D305EA712D05)
            - 2.7.1 单个键管理 [📖](marginnote3app://note/21C59B22-9548-48F6-B817-F7AC9F993F8D)
                - migrate命令也是用于在Redis实例间进行数据迁移的,实际上migrate命令就是将dump、restore、del三个命令进行组合,从而简化了操作流程。 [📖](marginnote3app://note/8FE86095-75C3-4509-A868-41516943DF3B)
            - 2.7.2 遍历键 [📖](marginnote3app://note/0298743F-03A2-4E1B-BF1F-77DACBC192EA)
                - scan命令渐进式的遍历所有键,可以有效防止阻塞 [📖](marginnote3app://note/BC7C47E3-8756-4456-8E1C-A65C3DB5FF21)
            - 2.7.3 数据库管理 [📖](marginnote3app://note/A1D5EC1A-9803-4F45-9BE1-B7869A8E40CB)
        - 2.8 本章重点回顾 [📖](marginnote3app://note/6C017EE8-7E09-46BA-BE68-D8322B9D2119)
            - scan命令可以解决keys命令可能带来的阻塞问题,同时Redis还提供了hscan、sscan、zscan渐进式地遍历hash、set、zset。 [📖](marginnote3app://note/D2866D82-80A6-4FEE-9BFB-A4CB3FC172C2)
    - 第3章 小功能大用处 [📖](marginnote3app://note/F9479D29-EAEA-4FA6-AEAB-66D0D1F83F77)
        - 3.1 慢查询分析 [📖](marginnote3app://note/5CCE5C22-62DD-4BA9-9879-1D58F9800E9A)
            - 3.1.1 慢查询的两个配置参数 [📖](marginnote3app://note/00F004EE-856D-4CF2-A969-2A881EDAD410)
            - 3.1.2 最佳实践 [📖](marginnote3app://note/87695C50-23BF-462F-9CE1-B6B9630956F1)
                - ·slowlog-max-len配置建议:线上建议调大慢查询列表,记录慢查询时Redis会对长命令做截断操作,并不会占用大量内存 [📖](marginnote3app://note/0F0CE0C0-4F1C-4C76-BCEF-87F022CE9452)
                - slowlog-log-slower-than配置建议:默认值超过10毫秒判定为慢查询 [📖](marginnote3app://note/83C852C3-B183-4B67-B6C7-BD16950DECC0)
                - 慢查询只记录命令执行时间,并不包括命令排队和网络传输时间 [📖](marginnote3app://note/1DD90845-F386-47D7-9D58-F847714E2A2C)
        - 3.2 Redis Shell [📖](marginnote3app://note/B26E2A17-F69B-4085-9695-DE2941FAD5A3)
            - 3.2.1 redis-cli详解 [📖](marginnote3app://note/CB6E0542-872B-4BCA-A30A-528C82EF436E)
                - -r(repeat)选项代表将命令执行多次 [📖](marginnote3app://note/223D03F2-AE72-435E-BA24-0DC403668A3E)
                - -i(interval)选项代表每隔几秒执行一次命令,但是-i选项必须和-r选项一起使用 [📖](marginnote3app://note/64701A13-5B0C-4971-98C6-C9BD3BD08FC9)
                - 注意-i的单位是秒,不支持毫秒为单位,但是如果想以每隔10毫秒执行一次,可以用-i0.01 [📖](marginnote3app://note/8AC6EF59-62B8-484F-A9CE-D2A64418F957)
                - -c(cluster)选项是连接Redis Cluster节点时需要使用的,-c选项可以防止moved和ask异常 [📖](marginnote3app://note/171C5FF2-0A59-4077-9C5D-B07AE0381545)
                - 如果Redis配置了密码,可以用-a(auth)选项,有了这个选项就不需要手动输入auth命令 [📖](marginnote3app://note/1FA7CE5B-8744-44BB-9D8F-B688098FD6C7)
                - --eval选项用于执行指定Lua脚本 [📖](marginnote3app://note/64CCC932-3376-474F-9FD8-0BE6C0F6DB98)
                - --stat选项可以实时获取Redis的重要统计信息 [📖](marginnote3app://note/A42A3961-7281-403C-8FC1-52C09E7ABE44)
                - --no-raw选项是要求命令的返回结果必须是原始的格式 [📖](marginnote3app://note/B8A223A4-C19F-4FF8-9459-BFDC8551BEC1)
                - --raw恰恰相反,返回格式化后的结果 [📖](marginnote3app://note/6B98282A-8E38-4C6F-B759-D827FCA6AC0B)
            - 3.2.2 redis-server详解 [📖](marginnote3app://note/6B646BD5-DEFB-43FD-AA76-7AA7B1669C68)
            - 3.2.3 redis-benchmark详解 [📖](marginnote3app://note/D1B39D92-E444-4FC5-9F65-38070400FB81)
                - -c(clients)选项代表客户端的并发数量(默认是50) [📖](marginnote3app://note/E4AC598E-3657-420C-8BB4-E54A077443E0)
                - -P选项代表每个请求pipeline的数据量(默认为1) [📖](marginnote3app://note/C6C1BF25-E211-40F6-8340-86B51B3CBDC8)
                - -k选项代表客户端是否使用keepalive [📖](marginnote3app://note/EF343D19-273D-42CD-B279-9F17B2772542)
        - 3.3 Pipeline [📖](marginnote3app://note/39BE711E-5E62-4757-AA21-D2CC70165587)
            - 3.3.1 Pipeline概念 [📖](marginnote3app://note/EEBD9650-FE77-4639-8D93-D565430183DE)
            - 3.3.2 性能测试 [📖](marginnote3app://note/7E616A2C-D10E-460C-A6E2-28630E4A8C5E)
            - 3.3.3 原生批量命令与Pipeline对比 [📖](marginnote3app://note/CF8AD5EE-15A6-46E7-B6A2-70DE49E0BBFE)
                - 原生批量命令是原子的,Pipeline是非原子的 [📖](marginnote3app://note/C3ADAF30-6F47-4DC8-81B0-F839867F1C2C)
                - 原生批量命令是一个命令对应多个key,Pipeline支持多个命令 [📖](marginnote3app://note/365A0776-2B7E-4E65-99BC-7DDFE1813D1C)
                - 原生批量命令是Redis服务端支持实现的,而Pipeline需要服务端和客户端的共同实现 [📖](marginnote3app://note/0D036095-1C8A-466C-8566-D080D7E25457)
            - 3.3.4 最佳实践 [📖](marginnote3app://note/8AA8B550-02F5-4E90-A76F-B4EB26B7F70B)
                - Pipeline虽然好用,但是每次Pipeline组装的命令个数不能没有节制,否则一次组装Pipeline数据量过大,一方面会增加客户端的等待时间,另一方面会造成一定的网络阻塞 [📖](marginnote3app://note/3A32D323-239C-467F-BB86-E0D8A493F0FC)
        - 3.4 事务与Lua [📖](marginnote3app://note/079E92A5-27F8-47B7-8A73-32DBEDB8975E)
            - 3.4.1 事务 [📖](marginnote3app://note/5870F3F3-7346-4A59-9063-B91E812A7101)
                - multi命令代表事务开始 [📖](marginnote3app://note/3484CB3A-F219-436C-91A0-A471EF6F274D)
                - exec命令代表事务结束 [📖](marginnote3app://note/11FE97BE-ECF9-45D3-BEF7-800D17AC78F2)
            - 3.4.2 Lua用法简述 [📖](marginnote3app://note/C731F4F2-672C-427C-8650-764FA9B4AB9E)
            - 3.4.3 Redis与Lua [📖](marginnote3app://note/44754481-A199-445D-9B39-6BD0E5D1E4D9)
                - 在Redis中执行Lua脚本有两种方法:eval和evalsha [📖](marginnote3app://note/F04CF750-5678-4EDA-809C-E0F968330D2C)
                - redis.call执行失败,那么脚本执行结束会直接返回错误 [📖](marginnote3app://note/9CD6BD80-D25B-47B7-A05F-A750522517AB)
                - redis.pcall如果执行失败,会忽略错误继续执行脚本 [📖](marginnote3app://note/16CE6DF7-0F3A-48AD-908C-080285019492)
            - 3.4.4 案例 [📖](marginnote3app://note/911E76EF-030F-44B6-8635-141979E5AC66)
            - 3.4.5 Redis如何管理Lua脚本 [📖](marginnote3app://note/32459FF1-381F-4404-A36F-C7DB545FAF05)
                - 如果当前Lua脚本正在执行写操作,那么script kill将不会生效 [📖](marginnote3app://note/33376684-B9ED-416B-8857-ACEBD1DCFA5D)
                - 当script kill执行之后,客户端调用会恢复 [📖](marginnote3app://note/CCC5A24B-89D8-4B9F-B058-B9DD8E53B554)
        - 3.5 Bitmaps [📖](marginnote3app://note/02DA9595-30BB-48A5-B5A2-A51A5A808E32)
            - 3.5.1 数据结构模型 [📖](marginnote3app://note/99FDA120-B86C-4E41-9E63-FE85C519ABCD)
            - 3.5.2 命令 [📖](marginnote3app://note/55C9B6C8-8008-44D9-84C0-FCEADB1E6C08)
            - 3.5.3 Bitmaps分析 [📖](marginnote3app://note/6481DC71-E324-4AAA-B7E0-D006EE1B6B83)
        - 3.6 HyperLogLog [📖](marginnote3app://note/6638B251-B520-419A-9FDC-E3D4FE33F319)
        - 3.7 发布订阅 [📖](marginnote3app://note/5C92356D-8253-4C5C-9411-66D2C27E2792)
            - 3.7.1 命令 [📖](marginnote3app://note/D2F98D3A-EF1B-4346-AA85-DACBE66B81E2)
            - 3.7.2 使用场景 [📖](marginnote3app://note/8801AF8F-D013-42A0-AD13-56E9883CB77E)
        - 3.8 GEO [📖](marginnote3app://note/236DD5A5-0AD3-48C2-A55B-C04C6032172C)
        - 3.9 本章重点回顾 [📖](marginnote3app://note/3A597823-FF9B-44B2-83B6-4353290BE285)
    - 第4章 客户端 [📖](marginnote3app://note/BFEBAFA3-F862-4F0F-8D89-1788A4109B16)
        - 4.1 客户端通信协议 [📖](marginnote3app://note/10B4A972-E6A6-4F82-B57D-CD19AB2C5E50)
        - 4.2 Java客户端Jedis [📖](marginnote3app://note/49ED4E5F-30F7-4A0D-9AB5-E93BE279569C)
            - 4.2.1 获取Jedis [📖](marginnote3app://note/5AD5EB7A-DD7D-4355-B218-989C4A6061DA)
            - 4.2.2 Jedis的基本使用方法 [📖](marginnote3app://note/5ED396AB-44F4-471F-ACCA-48099DE6CFD0)
            - 4.2.3 Jedis连接池的使用方法 [📖](marginnote3app://note/92A067EC-7BB9-47B5-AB67-260023B0FE2D)
            - 4.2.4 Redis中Pipeline的使用方法 [📖](marginnote3app://note/90EA510B-8CC8-422D-BA87-65EE865BEF3E)
                - 使用pipeline.sync()完成此次pipeline对象的调用 [📖](marginnote3app://note/88D26BD7-9534-41E7-A249-E46F877E55BA)
            - 4.2.5 Jedis的Lua脚本 [📖](marginnote3app://note/5AC3CA3E-8B2D-43A7-8EAA-8828F160ABC3)
        - 4.3 Python客户端redis-py [📖](marginnote3app://note/2A2A3392-44AF-405A-BC33-7AB5645D12FF)
            - 4.3.1 获取redis-py [📖](marginnote3app://note/D0B2406A-BD93-4805-810D-6006255ABE43)
            - 4.3.2 redis-py的基本使用方法 [📖](marginnote3app://note/DFB729CD-0CBF-46A3-A3FF-8FCE0C55122D)
            - 4.3.3 redis-py中Pipeline的使用方法 [📖](marginnote3app://note/ADD55DEC-99AE-4018-A1D8-F76262D4D7C7)
            - 4.3.4 redis-py中的Lua脚本使用方法 [📖](marginnote3app://note/74F27722-D4DC-44DB-9719-61A7E768445D)
        - 4.4 客户端管理 [📖](marginnote3app://note/76C40CB7-A92A-4666-B70F-CD107002EEFF)
            - 4.4.1 客户端API [📖](marginnote3app://note/91E3824A-8865-47F1-BF70-ABC124A2194E)
                - monitor命令能够监听其他客户端正在执行的命令,并记录了详细的时间戳 [📖](marginnote3app://note/FF25B18C-2DC6-48C6-B826-FA2DE07938C0)
                - 每个客户端都有自己的输出缓冲区,既然monitor能监听到所有的命令,一旦Redis的并发量过大, monitor客户端的输出缓冲会暴涨,可能瞬间会占用大量内存 [📖](marginnote3app://note/BA87C752-A93C-4736-9DD6-CDE120984BDB)
            - 4.4.2 客户端相关配置 [📖](marginnote3app://note/146A0578-B8AA-4A58-9581-4C81B33965DB)
            - 4.4.3 客户端统计片段 [📖](marginnote3app://note/74CDE546-E86C-4864-A6E3-B2B5D28F63FB)
        - 4.5 客户端常见异常 [📖](marginnote3app://note/7A210A78-848B-42F1-9B35-7004BD754335)
        - 4.6 客户端案例分析 [📖](marginnote3app://note/540381FA-625E-494E-AEED-FF228D01FA4C)
            - 4.6.1 Redis内存陡增 [📖](marginnote3app://note/907EAAE6-60B3-4678-BFD7-472560345CBC)
            - 4.6.2 客户端周期性的超时 [📖](marginnote3app://note/F8FF2FE9-41F8-4B4D-AD1A-B319DA2F8D50)
        - 4.7 本章重点回顾 [📖](marginnote3app://note/8B103BAB-B9D7-41AB-AB01-2C00E47F4AC7)
    - 第5章 持久化 [📖](marginnote3app://note/46BC80F4-92CA-43B4-B68B-4E4229C12DFD)
        - 5.1 RDB [📖](marginnote3app://note/7EE9EEE7-C415-4A84-90CC-9D4BE1153815)
            - 5.1.1 触发机制 [📖](marginnote3app://note/59664A03-2B86-4FC2-AD48-C6166D6E494C)
                - 手动触发分别对应save和bgsave命令 [📖](marginnote3app://note/689CDAEE-C6B5-4054-919E-53E6F3E3A4AE)
                - save命令:阻塞当前Redis服务器,直到RDB过程完成为止,对于内存比较大的实例会造成长时间阻塞,线上环境不建议使用 [📖](marginnote3app://note/2CDAC962-32D1-4FDE-B0A6-F7CC639D4DD7)
                - bgsave命令:Redis进程执行fork操作创建子进程,RDB持久化过程由子进程负责,完成后自动结束。阻塞只发生在fork阶段,一般时间很短。 [📖](marginnote3app://note/2F4B1060-ED78-4EEB-813E-FB626C3A9EAC)
                - bgsave命令是针对save阻塞问题做的优化 [📖](marginnote3app://note/21701CE7-CDC8-4425-BBC9-82ED5FA7B6CD)
                - Redis内部所有的涉及RDB的操作都采用bgsave的方式 [📖](marginnote3app://note/6E7BA309-543F-43ED-B23D-C05101BC44E9)
                - 默认情况下执行shutdown命令时,如果没有开启AOF持久化功能则自动执行bgsave [📖](marginnote3app://note/C366B06C-177D-4BAB-911A-70C60048E753)
            - 5.1.2 流程说明 [📖](marginnote3app://note/4E68A605-819A-4806-B3F5-E364BF121A9F)
                - 执行bgsave命令,Redis父进程判断当前是否存在正在执行的子进程,如RDB/AOF子进程,如果存在bgsave命令直接返回 [📖](marginnote3app://note/24C671D3-4757-4B7F-883E-CBA2E86480D7)
            - 5.1.3 RDB文件的处理 [📖](marginnote3app://note/D2B4997D-16B4-45F5-8790-1A8280754F94)
            - 5.1.4 RDB的优缺点 [📖](marginnote3app://note/11409714-D5D5-410B-8951-35C959DC7092)
                - ·RDB是一个紧凑压缩的二进制文件,代表Redis在某个时间点上的数据快照。非常适用于备份,全量复制等场景 [📖](marginnote3app://note/ED66E016-FFE1-41F4-9881-92F31C8F13C8)
                - ·Redis加载RDB恢复数据远远快于AOF的方式 [📖](marginnote3app://note/022BE274-DE99-430B-BD2C-DA736EA58ED3)
                - RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程,属于重量级操作,频繁执行成本过高。 [📖](marginnote3app://note/6269FCE8-552E-4C37-8BA1-D8C418F3F5E7)
                - RDB文件使用特定二进制格式保存,Redis版本演进过程中有多个格式的RDB版本,存在老版本Redis服务无法兼容新版RDB格式的问题 [📖](marginnote3app://note/F6A93ABE-C2CA-4F62-9EAC-CBB22AE679EF)
            - RDB持久化是把当前进程数据生成快照保存到硬盘的过程 [📖](marginnote3app://note/5197A4CC-CBF8-4904-927C-A453880BE565)
        - 5.2 AOF [📖](marginnote3app://note/C7BF3355-7778-4A14-8368-154673ED5B23)
            - 5.2.1 使用AOF [📖](marginnote3app://note/03E502E1-542E-4D07-BA1C-C361ED2C4FFD)
                - 随着AOF文件越来越大,需要定期对AOF文件进行重写,达到压缩的目的 [📖](marginnote3app://note/5AB1A8E0-51EC-4D6A-BF55-147210456D04)
                - 当Redis服务器重启时,可以加载AOF文件进行数据恢复 [📖](marginnote3app://note/A3213615-226A-48B8-8EF2-3A218F02076A)
            - 5.2.2 命令写入 [📖](marginnote3app://note/0DB9EEA3-E20D-4B8B-BA9C-7BFB8A5197E1)
                - AOF为什么直接采用文本协议格式 [📖](marginnote3app://note/3A578CFD-7D22-49C9-A60F-A7ECB78774DB)
                    - ·文本协议具有很好的兼容性 [📖](marginnote3app://note/1B6B11E2-6789-450A-8767-8835F727669C)
                    - ·开启AOF后,所有写入命令都包含追加操作,直接采用协议格式,避免了二次处理开销 [📖](marginnote3app://note/09E05C5C-51C0-4012-9631-D63D5881C024)
                    - ·文本协议具有可读性,方便直接修改和处理 [📖](marginnote3app://note/FEB48B24-0868-4D8E-992E-0BD1E07FE9DC)
            - 5.2.3 文件同步 [📖](marginnote3app://note/A8E44A90-C3E6-4F51-B227-C87F594D5AFC)
            - 5.2.4 重写机制 [📖](marginnote3app://note/C5F7B9C1-227C-4DDC-B5AC-CADD74C051F1)
            - 5.2.5 重启加载 [📖](marginnote3app://note/D056E75D-1325-49EF-9929-D629D9A7DADF)
            - 5.2.6 文件校验 [📖](marginnote3app://note/B651B381-B29F-4A07-802D-7608CD7A909A)
                - 加载损坏的AOF文件时会拒绝启动 [📖](marginnote3app://note/7F81461B-E7AF-4E33-BFD9-A9B5BF74D2A5)
                - 对于错误格式的AOF文件,先进行备份,然后采用redis-check-aof--fix命令进行修复,修复后使用diff-u对比数据的差异,找出丢失的数据,有些可以人工修改补全。 [📖](marginnote3app://note/BC652B98-8F22-43FA-837A-1423A85B5040)
            - AOF(append only file)持久化:以独立日志的方式记录每次写命令, 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性,目前已经是Redis持久化的主流方式 [📖](marginnote3app://note/C33A5041-50FA-46CF-B24B-E67209B9C56E)
        - 5.3 问题定位与优化 [📖](marginnote3app://note/A20A030A-4DD9-41AD-8681-E501F19C1D5C)
            - 5.3.1 fork操作 [📖](marginnote3app://note/E38515D1-7CCE-427B-8F4E-21E359D30DA9)
                - 虽然fork创建的子进程不需要拷贝父进程的物理内存空间,但是会复制父进程的空间内存页表 [📖](marginnote3app://note/C354E708-D581-4ED3-8CED-B0FDA0DDE74D)
                - fork 操作耗时跟进程总内存量息息相关,如果使用虚拟化技术,特别是Xen虚拟机,fork操作会更耗时 [📖](marginnote3app://note/87326F5A-1F12-41ED-9C95-33234ADA95A6)
                - 在info stats统计中查latest_fork_usec指标获取最近一次fork操作耗时,单位微秒 [📖](marginnote3app://note/C2210869-EB64-4FF3-879E-23BD78913CD3)
                - 改善fork操作的耗时: [📖](marginnote3app://note/9CA3FE4D-C8E0-4BBA-B1F8-C94033B0765D)
                    - 1)优先使用物理机或者高效支持fork操作的虚拟化技术,避免使用Xen。 [📖](marginnote3app://note/B4F4D7E7-E9CD-4767-B3CA-E8F6360012B6)
                    - 2)控制Redis实例最大可用内存,fork耗时跟内存量成正比,线上建议每个Redis实例内存控制在10GB以内。 [📖](marginnote3app://note/39794D6F-495B-4E7F-B9A9-F48572A53695)
                    - 3)合理配置Linux内存分配策略,避免物理内存不足导致fork失败 [📖](marginnote3app://note/EC6E9C59-16ED-4EA5-9520-94FD142EE982)
                    - 4)降低fork操作的频率,如适度放宽AOF自动触发时机,避免不必要的全量复制等。 [📖](marginnote3app://note/541FBE65-3760-4E44-B029-43680D4DA665)
            - 5.3.2 子进程开销监控和优化 [📖](marginnote3app://note/8E75E27F-CB81-4C23-80FA-F12FCDF71558)
                - 子进程负责AOF或者RDB文件的重写,它的运行过程主要涉及CPU、内存、硬盘三部分的消耗。 [📖](marginnote3app://note/82E5F24E-8F74-469B-BCC2-AD9F01E02E45)
                - ·硬盘开销优化 [📖](marginnote3app://note/F354D32B-E7AD-4ABF-8DEC-9ACE18CEE6A7)
                    - a)不要和其他高硬盘负载的服务部署在一起。如:存储服务、消息队列服务等。 [📖](marginnote3app://note/E53AB230-52F5-470B-B155-CEA160ED188F)
                    - b)AOF重写时会消耗大量硬盘IO,可以开启配置no-appendfsync-onrewrite,默认关闭。表示在AOF重写期间不做fsync操作。 [📖](marginnote3app://note/EA6A4686-4E69-4E8A-902E-A5EB282F88A8)
                    - c)当开启AOF功能的Redis用于高流量写入场景时,如果使用普通机械磁盘,写入吞吐一般在100MB/s左右,这时Redis实例的瓶颈主要在AOF同步硬盘上。 [📖](marginnote3app://note/5F200987-5C6F-4B2A-A4D2-2107BF82C8A7)
                    - d)对于单机配置多个Redis实例的情况,可以配置不同实例分盘存储AOF文件,分摊硬盘写入压力。 [📖](marginnote3app://note/45B9F850-637E-4E0E-8DF1-C612B68B8650)
            - 5.3.3 AOF追加阻塞 [📖](marginnote3app://note/CA3A501F-0D0D-4F1A-B065-70F22C684D81)
        - 5.4 多实例部署 [📖](marginnote3app://note/5F23D73A-A990-4B3C-B80A-3EF37BBE934B)
        - 5.5 本章重点回顾 [📖](marginnote3app://note/EE6ABEE7-DBD0-43EA-835B-B2036FC29D51)
            - RDB使用一次性生成内存快照的方式,产生的文件紧凑压缩比更高,因此读取RDB恢复速度更快。由于每次生成RDB开销较大,无法做到实时持久化,一般用于数据冷备和复制传输。 [📖](marginnote3app://note/AFCC533D-498D-40B1-B65C-B5EC07FD1EEF)
            - save命令会阻塞主线程不建议使用,bgsave命令通过fork操作创建子进程生成RDB避免阻塞。 [📖](marginnote3app://note/43899F6B-2C84-4487-82F6-B6BA8A746AA4)
            - AOF通过追加写命令到文件实现持久化,通过appendfsync参数可以控制实时/秒级持久化。因为需要不断追加写命令,所以AOF文件体积逐渐变大,需要定期执行重写操作来降低文件体积。 [📖](marginnote3app://note/E26201DA-8CC3-4A88-B7B9-FC90D9359C33)
            - 子进程执行期间使用copy-on-write机制与父进程共享内存,避免内存消耗翻倍。AOF重写期间还需要维护重写缓冲区,保存新的写入命令避免数据丢失。 [📖](marginnote3app://note/93CFB698-F456-430A-A292-BEB18E86069D)
            - 持久化阻塞主线程场景有:fork阻塞和AOF追加阻塞。fork阻塞时间跟内存量和系统有关,AOF追加阻塞说明硬盘资源紧张。 [📖](marginnote3app://note/64986074-B2C6-4563-B99F-7D34C0976EFB)
            - 单机下部署多个实例时,为了防止出现多个子进程执行重写操作, 建议做隔离控制,避免CPU和IO资源竞争。 [📖](marginnote3app://note/3D5DEFA9-8C28-421A-A965-D9FDBADFA5E9)
    - 第6章 复制 [📖](marginnote3app://note/9901E3D2-9EB1-4934-B441-6BFEBB872352)
        - 6.1 配置 [📖](marginnote3app://note/76B04B01-BD11-4CDD-AE34-D33FF3C2023E)
            - 6.1.1 建立复制 [📖](marginnote3app://note/D5E583EC-CF58-45AD-881A-21474D418E90)
                - slaveof配置都是在从节点发起 [📖](marginnote3app://note/5A2AF8FF-EC5B-437D-B902-4DAA3127E18A)
                - slaveof本身是异步命令,执行slaveof命令时,节点只保存主节点信息后返回,后续复制流程在节点内部异步执行 [📖](marginnote3app://note/A3C64EB7-9A2E-4DED-A692-6E91A4D2FB92)
            - 6.1.2 断开复制 [📖](marginnote3app://note/19E37A7D-E892-4740-BFFB-2E6F776B54B8)
                - slaveof命令不但可以建立复制,还可以在从节点执行slaveof no one来断开与主节点复制关系 [📖](marginnote3app://note/0881A0D0-B4FB-4088-AD12-83ECA420E23F)
                - 断开复制主要流程: [📖](marginnote3app://note/C243B751-CAB9-41E0-BCE8-CFF0253E1416)
                    - 1)断开与主节点复制关系。 [📖](marginnote3app://note/B5CE016F-3C05-46FC-A0E3-8FCDFCBCEC92)
                    - 2)从节点晋升为主节点。 [📖](marginnote3app://note/3B722792-9B00-453C-B2C9-C423547A9B50)
                - 从节点断开复制后并不会抛弃原有数据,只是无法再获取主节点上的数据变化。 [📖](marginnote3app://note/0D1D9023-6EB6-4090-AA6A-1F9395A4EE01)
                - 通过slaveof命令还可以实现切主操作,所谓切主是指把当前从节点对主节点的复制切换到另一个主节点 [📖](marginnote3app://note/8E54C9EB-FE41-4204-8F6E-103B63707FE2)
                - 切主操作流程如下: [📖](marginnote3app://note/1B7EFC22-C2D4-4D19-B262-8DD5B302E74A)
                    - 1)断开与旧主节点复制关系。 [📖](marginnote3app://note/3612853C-F730-4ED3-AD7E-39A157075EB5)
                    - 2)与新主节点建立复制关系。 [📖](marginnote3app://note/73C5E28C-798A-48F1-AF2A-7C3BEE5A3103)
                    - 3)删除从节点当前所有数据。 [📖](marginnote3app://note/D294F9FE-5EC6-4A3D-AA9B-13C43B5360B4)
                    - 4)对新主节点进行复制操作。 [📖](marginnote3app://note/A77FB689-4B14-4A63-A07D-05FDC5711F7D)
                - 切主后从节点会清空之前所有的数据 [📖](marginnote3app://note/F98E3C55-7DCC-4D77-B988-90E1D8EC017B)
            - 6.1.3 安全性 [📖](marginnote3app://note/CB0E90F2-353F-4286-9031-B464ECF75B2B)
            - 6.1.4 只读 [📖](marginnote3app://note/5549EB26-186F-4302-B793-FFC83C82377A)
            - 6.1.5 传输延迟 [📖](marginnote3app://note/61CE1FF5-077B-4D04-800F-CA664110CF64)
        - 6.2 拓扑 [📖](marginnote3app://note/33128FAA-1CD9-4151-BDC5-A6A8627F0A75)
            - 一主一从结构是最简单的复制拓扑结构,用于主节点出现宕机时从节点提供故障转移支持 [📖](marginnote3app://note/3AB40116-9DCC-40CC-9182-FEE1882953DB)
            - 当应用写命令并发量较高且需要持久化时,可以只在从节点上开启AOF,这样既保证数据安全性同时也避免了持久化对主节点的性能干扰。 [📖](marginnote3app://note/1085734E-107C-4D59-9E00-BBD9AD6DB77C)
            - 对于写并发量较高的场景,多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽,同时也加重了主节点的负载影响服务稳定性。 [📖](marginnote3app://note/71973615-846B-4986-8938-D4F66759E051)
            - 树状主从结构(又称为树状拓扑结构)使得从节点不但可以复制主节点数据,同时可以作为其他从节点的主节点继续向下层复制 [📖](marginnote3app://note/D78D6123-92B6-400A-8AB0-7BFD9C8F8647)
        - 6.3 原理 [📖](marginnote3app://note/851E24BF-8ED9-49C3-9A10-8167B962C1DB)
            - 6.3.1 复制过程 [📖](marginnote3app://note/066FBBDF-CCF5-4D8D-B3C5-096197ABA7BD)
                - 复制过程大致分为6个过程: [📖](marginnote3app://note/682F8BF9-1C05-45E3-BAF1-1A2AEB6C554B)
                    - 1)保存主节点(master)信息 [📖](marginnote3app://note/837D45BB-F2DA-4416-A4C6-C9624B78A545)
                    - 2)从节点(slave)内部通过每秒运行的定时任务维护复制相关逻辑, 当定时任务发现存在新的主节点后,会尝试与该节点建立网络连接 [📖](marginnote3app://note/7BA8C58F-DF8E-4B5E-938E-D5A16978FCD8)
                    - 3)发送ping命令 [📖](marginnote3app://note/6A7284D5-94F5-404B-AB99-F28FCD787F3C)
                    - 5)同步数据集 [📖](marginnote3app://note/FD0FF9EC-14DE-4C19-AD82-45AAA7861FF4)
                    - 6)命令持续复制 [📖](marginnote3app://note/94BAAE88-62D4-4089-B21F-7987A0FF03CB)
                    - 4)权限验证 [📖](marginnote3app://note/E0A6551D-3C4B-4974-94CE-4AEF0A2D4B1B)
            - 6.3.2 数据同步 [📖](marginnote3app://note/789B6108-548F-42A8-BAC6-C19812F77844)
                - 同步过程分为:全量复制和部分复制 [📖](marginnote3app://note/6A80E248-3DAC-415B-A6BF-A5C54F24EDD3)
                - 全量复制:一般用于初次复制场景,Redis早期支持的复制功能只有全量复制,它会把主节点全部数据一次性发送给从节点,当数据量较大时,会对主从节点和网络造成很大的开销 [📖](marginnote3app://note/E076F880-917E-4DBC-8169-98C230336720)
                - 部分复制:用于处理在主从复制中因网络闪断等原因造成的数据丢失场景,当从节点再次连上主节点后,如果条件允许,主节点会补发丢失数据给从节点。因为补发的数据远远小于全量数据,可以有效避免全量复制的过高开销。 [📖](marginnote3app://note/C0B12CC6-A037-4B03-9CAB-17E54FA2145D)
                - debug reload命令会阻塞当前Redis节点主线程,阻塞期间会生成本地RDB快照并清空数据之后再加载RDB文件 [📖](marginnote3app://note/4D5312A5-ECFF-4BAA-943A-7E4AC09B7872)
            - 6.3.3 全量复制 [📖](marginnote3app://note/5F83E927-B7FA-4DB0-9433-F1AB1EED399B)
                - 全量复制是Redis最早支持的复制方式,也是主从第一次建立复制时必须经历的阶段 [📖](marginnote3app://note/6EC0AC3D-293C-4244-B73A-A986BCA799F8)
                - 全量复制是一个非常耗时费力的操作。它的时间开销主要包括: [📖](marginnote3app://note/ABD0F02C-E470-4C0C-A7AA-D93D158CA394)
                    - 从节点清空数据时间 [📖](marginnote3app://note/665264B7-4084-467C-BAD2-08C9CC5F6448)
                    - 从节点加载RDB的时间 [📖](marginnote3app://note/035E5F63-3F4B-429F-9175-7E83CD20FD39)
                    - 可能的AOF重写时间 [📖](marginnote3app://note/8974EE3A-76E8-4712-AA37-A9A403C4E135)
                    - 主节点bgsave时间 [📖](marginnote3app://note/C43BF21F-6879-4ECB-8A03-941DDD5EBC32)
                    - RDB文件网络传输时间 [📖](marginnote3app://note/8F0E4CC0-5C9C-495D-B911-D89C8E4BC270)
            - 6.3.4 部分复制 [📖](marginnote3app://note/8A2DA0F3-BDE6-407C-87F6-BA028B139DAA)
                - 部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施, 使用psync{runId}{offset}命令实现 [📖](marginnote3app://note/2B26ECFF-2A50-442C-A4B3-2B6947B844AA)
                - 当从节点(slave)正在复制主节点(master)时,如果出现网络闪断或者命令丢失等异常情况时,从节点会向主节点要求补发丢失的命令数据,如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点,这样就可以保持主从节点复制的一致性。补发的这部分数据一般远远小于全量数据,所以开销很小。 [📖](marginnote3app://note/213FE51D-AEB7-40C7-BC30-563D4B701CCC)
            - 6.3.5 心跳 [📖](marginnote3app://note/381510C1-2B8C-4B67-A49B-C77F7306660F)
                - 为了降低主从延迟,一般把Redis主从节点部署在相同的机房/同城机房,避免网络延迟和网络分区造成的心跳中断等情况。 [📖](marginnote3app://note/40924C48-E423-42FF-951C-06F8309CB009)
                - 主从心跳判断机制: [📖](marginnote3app://note/74973058-F2B9-4158-BBC4-421CFEE16A60)
                    - 1)主从节点彼此都有心跳检测机制,各自模拟成对方的客户端进行通信,通过client list命令查看复制相关客户端信息,主节点的连接状态为flags=M,从节点连接状态为flags=S。 [📖](marginnote3app://note/B7EEB66B-D01B-4254-995E-BE3352EF477B)
                    - 2)主节点默认每隔10秒对从节点发送ping命令,判断从节点的存活性和连接状态。可通过参数repl-ping-slave-period控制发送频率。 [📖](marginnote3app://note/7C29AAD1-5A9B-41FE-8924-2B6A6A7B9834)
                    - 3)从节点在主线程中每隔1秒发送replconf ack{offset}命令,给主节点上报自身当前的复制偏移量。 [📖](marginnote3app://note/542754A4-9CA7-41AA-81B1-50213049F27E)
                        - replconf命令主要作用如下: [📖](marginnote3app://note/136E5C62-074D-42FB-89F1-01D4F7C8E219)
                            - 实时监测主从节点网络状态。 [📖](marginnote3app://note/9F20FF5E-EB58-4CE7-A7A1-B57DB0180366)
                            - 上报自身复制偏移量,检查复制数据是否丢失,如果从节点数据丢失,再从主节点的复制缓冲区中拉取丢失数据。 [📖](marginnote3app://note/41E97226-1DF5-4289-8D25-6B33B29D1A9A)
                            - ·实现保证从节点的数量和延迟性功能,通过min-slaves-to-write、minslaves-max-lag参数配置定义。 [📖](marginnote3app://note/E21E8328-80DC-4139-AF96-FE7DFF72F601)
            - 6.3.6 异步复制 [📖](marginnote3app://note/2A8CF9DA-AC4D-497D-A258-A2B7AD517771)
                - 主节点不但负责数据读写,还负责把写命令同步给从节点。写命令的发送过程是异步完成,也就是说主节点自身处理完写命令后直接返回给客户端,并不等待从节点复制完成 [📖](marginnote3app://note/6DF61097-4F40-483F-9CDB-04A8944A41EF)
        - 6.4 开发与运维中的问题 [📖](marginnote3app://note/A93E4784-F9AE-4ADB-999A-81393CC378EA)
            - 6.4.1 读写分离 [📖](marginnote3app://note/CA22E2A6-79D4-48F1-AE9A-F76FE551C65F)
                - 需要注意永远只对主节点执行写操作 [📖](marginnote3app://note/8CA3A8C1-00F7-494F-B4E1-C1239415738E)
                - 从节点数据延迟 [📖](marginnote3app://note/A0EC814F-FF13-4F8B-A0EA-C33BB14A63EA)
                    - Redis复制数据的延迟由于异步复制特性是无法避免的,延迟取决于网络带宽和命令阻塞情况,比如刚在主节点写入数据后立刻在从节点上读取可能获取不到。需要业务场景允许短时间内的数据延迟。对于无法容忍大量延迟场景,可以编写外部监控程序监听主从节点的复制偏移量,当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点 [📖](marginnote3app://note/BB00AE13-C1F1-48A1-A7F9-399AFFC3C097)
                        - 1)监控程序(monitor)定期检查主从节点的偏移量,主节点偏移量在info replication的master_repl_offset指标记录,从节点偏移量可以查询主节点的slave0字段的offset指标,它们的差值就是主从节点延迟的字节量。 [📖](marginnote3app://note/C6BB5290-FC0D-4651-AFCF-FAC3472417C3)
                        - 2)当延迟字节量过高时,比如超过10MB。监控程序触发报警并通知客户端从节点延迟过高。可以采用Zookeeper的监听回调机制实现客户端通知。 [📖](marginnote3app://note/824E3156-FB08-48C0-92E7-6C2A9D3384A3)
                        - 3)客户端接到具体的从节点高延迟通知后,修改读命令路由到其他从节点或主节点上。当延迟恢复后,再次通知客户端,恢复从节点的读命令请求。 [📖](marginnote3app://note/FDAE3BDA-2D64-4CA1-93A4-47D0F3BDDA22)
            - 6.4.2 主从配置不一致 [📖](marginnote3app://note/19FE5B3D-22BE-434A-80D0-1111BCBD22FD)
            - 6.4.3 规避全量复制 [📖](marginnote3app://note/492A3142-EE66-4B29-9C43-6D02D72EAE6F)
                - ·第一次建立复制:由于是第一次建立复制,从节点不包含任何主节点数据,因此必须进行全量复制才能完成数据同步。对于这种情况全量复制无法避免。当对数据量较大且流量较高的主节点添加从节点时,建议在低峰时进行操作,或者尽量规避使用大数据量的Redis节点。 [📖](marginnote3app://note/1E9EC749-62E5-4F37-A023-B456AEDBFF7C)
                - 节点运行ID不匹配:当主从复制关系建立后,从节点会保存主节点的运行ID,如果此时主节点因故障重启,那么它的运行ID会改变,从节点发现主节点运行ID不匹配时,会认为自己复制的是一个新的主节点从而进行全量复制。对于这种情况应该从架构上规避,比如提供故障转移功能。 [📖](marginnote3app://note/3A295775-BA2C-4529-AD42-12F544ABA4E2)
                - ·复制积压缓冲区不足:当主从节点网络中断后,从节点再次连上主节点时会发送psync{offset}{runId}命令请求部分复制,如果请求的偏移量不在主节点的积压缓冲区内,则无法提供给从节点数据,因此部分复制会退化为全量复制。针对这种情况需要根据网络中断时长,写命令数据量分析出合理的积压缓冲区大小。 [📖](marginnote3app://note/8A63C13D-4460-408B-B31A-05715B4D406C)
            - 6.4.4 规避复制风暴 [📖](marginnote3app://note/16B78366-8813-48BE-8E37-41239C247977)
                - 复制风暴是指大量从节点对同一主节点或者对同一台机器的多个主节点短时间内发起全量复制的过程。 [📖](marginnote3app://note/F92DDBAF-F5A5-48F4-BFFA-3837FBE65370)
                - 单主节点复制风暴 [📖](marginnote3app://note/63110B6D-6F89-4CC9-824A-E1412A13AB9F)
                    - 单主节点复制风暴一般发生在主节点挂载多个从节点的场景。当主节点重启恢复后,从节点会发起全量复制流程,这时主节点就会为从节点创建RDB快照,如果在快照创建完毕之前,有多个从节点都尝试与主节点进行全量同步,那么其他从节点将共享这份RDB快照。 [📖](marginnote3app://note/3A9ED449-6DD3-42C0-9031-D3264D5E82EF)
                    - 解决方案首先可以减少主节点(master)挂载从节点(slave)的数量, 或者采用树状复制结构,加入中间层从节点用来保护主节点 [📖](marginnote3app://note/92AC9DDA-634C-4B9E-96F4-94C03C40398B)
        - 6.5 本章重点回顾 [📖](marginnote3app://note/B772DD9B-7592-4B0C-A214-309BD7B89656)
            - Redis通过复制功能实现主节点的多个副本。从节点可灵活地通过slaveof命令建立或断开复制流程。 [📖](marginnote3app://note/9C1CEB88-0329-4EF6-B6FC-CC977D5F7ED4)
            - 复制支持树状结构,从节点可以复制另一个从节点,实现一层层向下的复制流。 [📖](marginnote3app://note/9090A298-4368-45DA-98EA-A8ADD664F927)
            - 主从节点之间维护心跳和偏移量检查机制,保证主从节点通信正常和数据一致。 [📖](marginnote3app://note/2F6F68B8-5698-4302-A068-89392C337D79)
            - Redis为了保证高性能复制过程是异步的,写命令处理完后直接返回给客户端,不等待从节点复制完成。因此从节点数据集会有延迟情况。 [📖](marginnote3app://note/0612FCF0-F514-4191-9407-140685EA3BFD)
            - 当使用从节点用于读写分离时会存在数据延迟、过期数据、从节点可用性等问题,需要根据自身业务提前作出规避。 [📖](marginnote3app://note/61F334F9-2675-4D39-AEFE-A2B8E248ACCE)
            - 在运维过程中,主节点存在多个从节点或者一台机器上部署大量主节点的情况下,会有复制风暴的风险。 [📖](marginnote3app://note/C2156632-3DAB-4A6E-B578-954262031AE7)
    - 第7章 Redis的噩梦：阻塞 [📖](marginnote3app://note/9E935525-F82A-48F8-BF76-DE3E9AB8DAB2)
        - 7.1 发现阻塞 [📖](marginnote3app://note/FDD5CA13-F678-4388-A504-C9295D600143)
        - 7.2 内在原因 [📖](marginnote3app://note/6A0FA440-BBF4-4657-AE95-BF09F9A7E9BC)
            - 7.2.1 API或数据结构使用不合理 [📖](marginnote3app://note/7858C8EA-84C2-4962-A5CD-D9834D8B651C)
                - 执行slowlog get{n}命令可以获取最近的n条慢查询命令,默认对于执行超过10毫秒的命令都会记录到一个定长队列中,线上实例建议设置为1毫秒便于及时发现毫秒级以上的命令 [📖](marginnote3app://note/DD9C79F7-A820-4176-8B0B-2E57F160015E)
            - 7.2.2 CPU饱和 [📖](marginnote3app://note/FB850DBB-65F8-4C0A-88FF-15F792D8F5E1)
                - CPU饱和是指Redis把单核CPU使用率跑到接近100% [📖](marginnote3app://note/835AB068-DFCF-4C8A-ACE6-DC2B6AE30EA0)
            - 7.2.3 持久化阻塞 [📖](marginnote3app://note/6BB73A89-9204-4761-9690-E5E18923A0CD)
                - 持久化引起主线程阻塞的操作主要有:fork阻塞、AOF刷盘阻塞、HugePage写操作阻塞。 [📖](marginnote3app://note/6B301656-B175-4BB5-BE1B-80D6246C988A)
                - fork操作发生在RDB和AOF重写时,Redis主线程调用fork操作产生共享内存的子进程,由子进程完成持久化文件重写工作。 [📖](marginnote3app://note/955F1758-01BA-4CDD-AFD4-9E1CFF170724)
                - 当我们开启AOF持久化功能时,文件刷盘的方式一般采用每秒一次,后台线程每秒对AOF文件做fsync操作。 [📖](marginnote3app://note/0C63BB5E-8772-40C7-B30A-E955764576F1)
        - 7.3 外在原因 [📖](marginnote3app://note/090312EA-9285-4717-A42D-A6B2D7AE2F62)
            - 7.3.1 CPU竞争 [📖](marginnote3app://note/91368EA7-07FC-4554-B909-95E85E437056)
                - Redis是典型的CPU密集型应用,不建议和其他多核CPU密集型服务部署在一起。 [📖](marginnote3app://note/D88CF166-DC8B-4240-9FC3-EC491D538393)
                - 当其他进程过度消耗CPU时,将严重影响Redis吞吐量。 [📖](marginnote3app://note/BA14600C-553D-4B66-8EFA-1831D6F406FC)
                - 绑定CPU:部署Redis时为了充分利用多核CPU,通常一台机器部署多个实例。常见的一种优化是把Redis进程绑定到CPU上,用于降低CPU频繁上下文切换的开销。 [📖](marginnote3app://note/F8515FBE-36A8-4445-9DF3-4217A5F8C953)
                - 当Redis父进程创建子进程进行RDB/AOF重写时,如果做了CPU绑定, 会与父进程共享使用一个CPU。子进程重写时对单核CPU使用率通常在90% 以上,父进程与子进程将产生激烈CPU竞争,极大影响Redis稳定性。因此对于开启了持久化或参与复制的主节点不建议绑定CPU。 [📖](marginnote3app://note/7A702593-9F05-46D5-AE82-8E952F9AE771)
            - 7.3.2 内存交换 [📖](marginnote3app://note/AF1A9E6A-12E3-4CE4-A526-29AF189EC7DB)
                - 内存交换(swap)对于Redis来说是非常致命的,Redis保证高性能的一个重要前提是所有的数据在内存中。 [📖](marginnote3app://note/A00E4148-B21E-4976-92CB-39B8DB6AA030)
                - 预防内存交换的方法有: [📖](marginnote3app://note/747F86F8-BF82-4BEF-A87E-222EDF6794CB)
                    - 保证机器充足的可用内存 [📖](marginnote3app://note/3D56B68A-B11C-4288-9540-7C15ADEEECE3)
                    - 确保所有Redis实例设置最大可用内存(maxmemory),防止极端情况下Redis内存不可控的增长 [📖](marginnote3app://note/EB626635-0B7A-4A0A-9618-2FAF376745E6)
                    - 降低系统使用swap优先级,如echo10>/proc/sys/vm/swappiness [📖](marginnote3app://note/04D668BF-F9E8-45CE-BB67-960654DAF9AB)
            - 7.3.3 网络问题 [📖](marginnote3app://note/C29B07E7-4B44-4B2C-9DB9-7E5BE45A6620)
                - 连接拒绝 [📖](marginnote3app://note/58735F92-AD8B-4A05-B744-0E6E2FB28155)
                    - 网络闪断。一般发生在网络割接或者带宽耗尽的情况,对于网络闪断的识别比较困难,常见的做法可以通过sar-n DEV查看本机历史流量是否正常,或者借助外部系统监控工具(如Ganglia)进行识别。具体问题定位需要更上层的运维支持,对于重要的Redis服务需要充分考虑部署架构的优化,尽量避免客户端与Redis之间异地跨机房调用。 [📖](marginnote3app://note/AE4472BC-C38A-473C-B9F0-1DF7E825686A)
                    - Redis连接拒绝。Redis通过maxclients参数控制客户端最大连接数,默认10000。当Redis连接数大于maxclients时会拒绝新的连接进入, info stats的rejected_connections统计指标记录所有被拒绝连接的数量 [📖](marginnote3app://note/D8EEA9B0-F229-4734-AC80-FCF7C10B4083)
                        - 因为客户端服务存在频繁启动和销毁的情况且默认Redis不会主动关闭长时间闲置连接或检查关闭无效的TCP连接,因此会导致Redis连接数快速消耗且无法释放的问题。这种场景下建议设置tcp-keepalive和timeout参数让Redis主动检查和关闭无效连接。 [📖](marginnote3app://note/8B6E5187-D05A-41FD-B93A-83E0F717B259)
                    - 连接溢出。这是指操作系统或者Redis客户端在连接时的问题。这个问题的原因比较多,下面就分别介绍两种原因:进程限制、backlog队列溢出。 [📖](marginnote3app://note/1566FF55-129E-4A78-B2CA-9E7C48D10C24)
                        - 进程限制 [📖](marginnote3app://note/8F7ABAFD-7DCF-4EE4-B39E-A16348922CE8)
                            - 客户端想成功连接上Redis服务需要**操作系统**和Redis的限制都通过才可以 [📖](marginnote3app://note/DB82DC31-7524-4B40-BD18-C9294DF90D7C)
                            - 操作系统一般会对进程使用的资源做限制,其中一项是对进程可打开最大文件数控制,通过ulimit-n查看,通常默认1024。由于Linux系统对TCP连接也定义为一个文件句柄,因此对于支撑大量连接的Redis来说需要增大这个值,如设置ulimit-n65535,防止Too many open files错误。 [📖](marginnote3app://note/DCCAD898-874E-4342-B96D-A3A6347AC320)
                        - backlog队列溢出 [📖](marginnote3app://note/9C5078D9-49F1-4C3E-A26F-12601CE63505)
                            - 系统对于特定端口的TCP连接使用backlog队列保存。Redis默认的长度为511,通过tcp-backlog参数设置。如果Redis用于高并发场景为了防止缓慢连接占用,可适当增大这个设置,但必须大于操作系统允许值才能生效。当Redis启动时如果tcp-backlog设置大于系统允许值将以系统值为准 [📖](marginnote3app://note/503ACE0F-B824-4795-90E6-C6F95C09A65B)
                            - 如果怀疑是backlog队列溢出,线上可以使用cron定时执行netstat-s|grep overflowed统计,查看是否有持续增长的连接拒绝情况。 [📖](marginnote3app://note/C36DD805-5495-40EA-8B3C-B52029E72B5F)
                - 常见的物理拓扑按网络延迟由快到慢可分为:同物理机>同机架>跨机架>同机房>同城机房>异地机房。但它们容灾性正好相反,同物理机容灾性最低而异地机房容灾性最高。 [📖](marginnote3app://note/071D279B-C719-47B6-8ECF-512E912EE7B2)
                - Redis提供了测量机器之间网络延迟的工具 [📖](marginnote3app://note/E9DFD68D-C83D-4C02-8215-1E1F3798BF08)
        - 7.4 本章重点回顾 [📖](marginnote3app://note/31D10B41-97A0-4A51-9F9F-3E39C236C4F2)
    - 第8章 理解内存 [📖](marginnote3app://note/28C5A910-B628-43DE-A2E9-BC2C1309281D)
        - 8.1 内存消耗 [📖](marginnote3app://note/D1C5A976-465D-4C84-9BA5-FAC079D4A02C)
            - 8.1.1 内存使用统计 [📖](marginnote3app://note/51ECC58E-E336-43EE-98F9-210D26E10C2D)
                - 了解Redis自身使用内存的统计数据,可通过执行info memory 命令获取内存相关指标 [📖](marginnote3app://note/4C0709B3-215D-42F0-B248-091B74C412FE)
            - 8.1.2 内存消耗划分 [📖](marginnote3app://note/3D43465E-4F58-4092-A6F3-C6B83523B618)
                - Redis进程内消耗主要包括:自身内存+对象内存+缓冲内存+内存碎片 [📖](marginnote3app://note/2A801CBC-0BAE-4B80-A562-79B55F570BB1)
                - 图8-1 Redis内存消耗划分 [📖](marginnote3app://note/56A38906-7204-48BE-9D55-39FC3725E3A3)
                - 对象内存是Redis内存占用最大的一块 [📖](marginnote3app://note/4BAEB0D9-5B12-4F54-9DCD-72E86AE08225)
                - Redis 所有的数据都采用key-value数据类型 [📖](marginnote3app://note/16E803AB-87D4-42BC-9D57-2CCD7ADF4399)
                - 对象内存消耗可以简单理解为sizeof(keys) +sizeof(values) [📖](marginnote3app://note/EDBA6F9C-FEFA-4DD4-BBE6-4D41E1466E09)
                - 键对象都是字符串,在使用Redis时很容易忽略键对内存消耗的影响,应当避免使用过长的键 [📖](marginnote3app://note/989F09FE-0888-4112-AB33-1F5680F5C8EA)
                - Bitmaps和HyperLogLog使用字符串实现 [📖](marginnote3app://note/4A889746-026B-4D87-9FF3-28D0FF0D3A35)
                - GEO使用有序集合实现 [📖](marginnote3app://note/8B2B70C3-2187-4FC5-A97C-8497776643B1)
                - 缓冲内存主要包括:客户端缓冲、复制积压缓冲区、AOF缓冲区 [📖](marginnote3app://note/BA1A90AA-60DC-49D6-B151-A940773F678F)
                - 客户端缓冲指的是所有接入到Redis服务器TCP连接的输入输出缓冲 [📖](marginnote3app://note/DC7F1E50-2EF4-40D8-BDC3-08C13F5DBA32)
                - 输入缓冲无法控制,最大空间为1G,如果超过将断开连接 [📖](marginnote3app://note/1F205C71-428B-4B68-B867-295F723FF49F)
                - Redis默认的内存分配器采用jemalloc,可选的分配器还有:glibc、tcmalloc [📖](marginnote3app://note/AF7125E4-87ED-4A6C-B332-A829170507FE)
                - 内存分配器为了更好地管理和重复利用内存,分配内存策略一般采用固定范围的内存块进行分配 [📖](marginnote3app://note/146264B7-BCDB-4A0B-9AEC-D638827D4D55)
                - 比如当保存5KB对象时jemalloc可能会采用8KB的块存储,而剩下的3KB 空间变为了内存碎片不能再分配给其他对象存储 [📖](marginnote3app://note/DD24A243-394C-49A5-B4C4-A3C343993066)
                - 出现高内存碎片问题时常见的解决方式如下: [📖](marginnote3app://note/5A64237F-42E6-4C03-84D6-A894E8CD793F)
                    - 数据对齐:在条件允许的情况下尽量做数据对齐,比如数据尽量采用数字类型或者固定长度字符串等,但是这要视具体的业务而定,有些场景无法做到。 [📖](marginnote3app://note/850AA77D-061C-4A2B-AEEE-57D1AB451DB9)
                    - 安全重启:重启节点可以做到内存碎片重新整理,因此可以利用高可用架构,如Sentinel或Cluster,将碎片率过高的主节点转换为从节点,进行安全重启。 [📖](marginnote3app://note/6A406356-A14F-4BB0-8384-5AF5C05A3F95)
            - 8.1.3 子进程内存消耗 [📖](marginnote3app://note/A49ED0BD-8ED1-46BF-ACE6-0228A601E2C2)
                - 子进程内存消耗主要指执行AOF/RDB重写时Redis创建的子进程内存消耗 [📖](marginnote3app://note/855630E8-485A-46C3-9C84-C33D807AA732)
                - Redis执行fork操作产生的子进程内存占用量对外表现为与父进程相同, 理论上需要一倍的物理内存来完成重写操作 [📖](marginnote3app://note/B741E860-7C47-423F-B5B4-66C538CA7F0F)
                - Linux具有写时复制技术(copy-on-write),父子进程会共享相同的物理内存页,当父进程处理写请求时会对需要修改的页复制出一份副本完成写操作,而子进程依然读取fork 时整个父进程的内存快照。 [📖](marginnote3app://note/314E23BE-6A85-481D-B7BD-58A61E45FD5E)
                - Redis产生的子进程并不需要消耗1倍的父进程内存,实际消耗根据期间写入命令量决定,但是依然要预留出一些内存防止溢出。 [📖](marginnote3app://note/51472D5F-3BF1-466C-BF91-436BB2740FE6)
                - 需要设置sysctl vm.overcommit_memory=1允许内核可以分配所有的物理内存,防止Redis进程执行fork时因系统剩余内存不足而失败。 [📖](marginnote3app://note/1460DBAF-C693-4313-A387-06B754D709B6)
            - 内存消耗可以分为进程自身消耗和子进程消耗 [📖](marginnote3app://note/A3EB95FF-9EF8-4044-A518-C412A58861FC)
        - 8.2 内存管理 [📖](marginnote3app://note/06F3BF9E-BFEA-412A-A0D5-C230194B5D28)
            - 8.2.1 设置内存上限 [📖](marginnote3app://note/272597AD-AA3B-41FF-A43C-83280CF62974)
            - 8.2.2 动态调整内存上限 [📖](marginnote3app://note/68DC417A-C181-4359-8272-3B639FC84CD4)
            - 8.2.3 内存回收策略 [📖](marginnote3app://note/9F901E42-FE5E-48F0-A330-A94DFABB77B3)
        - 8.3 内存优化 [📖](marginnote3app://note/F2A87FF2-67EB-4852-B1EA-8F71A66086B6)
            - 8.3.1 redisObject对象 [📖](marginnote3app://note/A7AEA3C6-5411-469B-9B6D-46123F1E3E74)
            - 8.3.2 缩减键值对象 [📖](marginnote3app://note/8B1A3D19-7E38-4C03-983E-44819DAE878D)
            - 8.3.3 共享对象池 [📖](marginnote3app://note/9E024518-CD72-4F3B-8471-B1DD9405560A)
            - 8.3.4 字符串优化 [📖](marginnote3app://note/27BD843D-39EC-46FB-B5E1-AA450AFE8BF8)
            - 8.3.5 编码优化 [📖](marginnote3app://note/0C4463C6-DE62-43AF-BB39-010042DAD368)
            - 8.3.6 控制键的数量 [📖](marginnote3app://note/781B47BD-5973-445F-9B42-B40E8126D22C)
        - 8.4 本章重点回顾 [📖](marginnote3app://note/ED2DE06D-126A-4C77-BB2C-DDA1A8E286C9)
    - 第9章 哨兵 [📖](marginnote3app://note/20A37834-F2F7-4FAC-91B2-5FACADDEF452)
        - 9.1 基本概念 [📖](marginnote3app://note/A2927236-2622-45E1-9C82-4E2B9EE01335)
            - 9.1.1 主从复制的问题 [📖](marginnote3app://note/995449C3-2374-45D9-82CE-2BA8B7A3293A)
            - 9.1.2 高可用 [📖](marginnote3app://note/7F6E5C21-E448-47A1-A26F-0D75F443EEAC)
            - 9.1.3 Redis Sentinel的高可用性 [📖](marginnote3app://note/9866CF58-798F-40F5-AF05-8AFE5B82B8C0)
        - 9.2 安装和部署 [📖](marginnote3app://note/A4D6B15F-D99D-4152-844E-F43DE453278D)
            - 9.2.1 部署拓扑结构 [📖](marginnote3app://note/800F7B8C-66A7-4224-A227-1467FCB1473F)
            - 9.2.2 部署Redis数据节点 [📖](marginnote3app://note/55F72BA2-10AE-41D8-BC51-621A5164C5EE)
            - 9.2.3 部署Sentinel节点 [📖](marginnote3app://note/88CCC102-7954-497E-BD8D-8E4B9CF12A08)
            - 9.2.4 配置优化 [📖](marginnote3app://note/34B35AE5-1119-4F8F-B751-BF9CC27EFB6A)
            - 9.2.5 部署技巧 [📖](marginnote3app://note/7394EA14-CB57-46D6-8E6A-CD5D04D8C39C)
        - 9.3 API [📖](marginnote3app://note/D6B0999F-DE57-44A1-9AAD-AB822E5B3307)
        - 9.4 客户端连接 [📖](marginnote3app://note/D1395332-D9AD-4F64-BF3E-90C144912467)
            - 9.4.1 Redis Sentinel的客户端 [📖](marginnote3app://note/35843D4F-57F7-4CE6-AECA-A102606551A5)
            - 9.4.2 Redis Sentinel客户端基本实现原理 [📖](marginnote3app://note/13560140-646D-49D3-9226-290D11AEB41E)
            - 9.4.3 Java操作Redis Sentinel [📖](marginnote3app://note/6FE5C54C-5F8E-4128-B30B-4D89F2A5999D)
        - 9.5 实现原理 [📖](marginnote3app://note/185DB81F-C3A2-4ADD-BA48-D9BF0EDAD9D1)
            - 9.5.1 三个定时监控任务 [📖](marginnote3app://note/4A4B65EA-BE35-4CD7-A16D-EB8B8AF6CC37)
            - 9.5.2 主观下线和客观下线 [📖](marginnote3app://note/DE5540EA-B7DA-4D2E-B918-EBD95A0AD04A)
            - 9.5.3 领导者Sentinel节点选举 [📖](marginnote3app://note/BF28F837-7BFD-4A81-B924-360B18FB919F)
            - 9.5.4 故障转移 [📖](marginnote3app://note/4CA70B28-ACF3-47FE-8E15-6EA83A575D10)
        - 9.6 开发与运维中的问题 [📖](marginnote3app://note/606306FA-FEAD-4249-BC22-020526CC7502)
            - 9.6.1 故障转移日志分析 [📖](marginnote3app://note/50307E49-4895-440D-B20E-3FAD9A7693F2)
            - 9.6.2 节点运维 [📖](marginnote3app://note/09D39B98-AC6C-4D15-B3B8-66F22710DE66)
            - 9.6.3 高可用读写分离 [📖](marginnote3app://note/1BEA9DCF-A6E9-4842-BAF0-9EE1F24C4948)
        - 9.7 本章重点回顾 [📖](marginnote3app://note/33C6C5D6-9AF1-4306-B4F9-403DA2387162)
    - 第10章 集群 [📖](marginnote3app://note/137B0A74-A68C-4D80-8EF9-F6207943F50C)
        - 10.1 数据分布 [📖](marginnote3app://note/DD52F70D-D623-4E8F-BA9A-3542E752E98E)
            - 10.1.1 数据分布理论 [📖](marginnote3app://note/A9668BA9-E356-4488-9093-5F96CB2E6E4F)
            - 10.1.2 Redis数据分区 [📖](marginnote3app://note/1A03D561-7B1F-4436-AF25-7AF931A5EB68)
            - 10.1.3 集群功能限制 [📖](marginnote3app://note/BD0BB987-75FF-4549-A5DA-288419CAA2D7)
        - 10.2 搭建集群 [📖](marginnote3app://note/BA72F2A8-31AA-4B1D-8316-9C7A48408BF7)
            - 10.2.1 准备节点 [📖](marginnote3app://note/04901F84-9A28-4650-A977-45DB08D1F042)
            - 10.2.2 节点握手 [📖](marginnote3app://note/0BF1B5C1-A348-4063-9412-17C5EC869C86)
            - 10.2.3 分配槽 [📖](marginnote3app://note/D3653A60-B7AC-42A5-8FFB-60E7FD72E119)
            - 10.2.4 用redis-trib.rb搭建集群 [📖](marginnote3app://note/326DA766-2A09-4E2A-973E-42121694235A)
        - 10.3 节点通信 [📖](marginnote3app://note/44A71B85-D0F8-4B1F-97F9-9F9EEE558197)
            - 10.3.1 通信流程 [📖](marginnote3app://note/D9119738-F515-4A60-8636-435B1BD99113)
            - 10.3.2 Gossip消息 [📖](marginnote3app://note/DA2F6491-1674-4E36-B5E5-47489EB9E042)
            - 10.3.3 节点选择 [📖](marginnote3app://note/5951406F-D172-483D-8F7B-CE5279C576C3)
        - 10.4 集群伸缩 [📖](marginnote3app://note/26DC2150-260C-415E-9D33-0D5BF621E5AD)
            - 10.4.1 伸缩原理 [📖](marginnote3app://note/6A95EAF4-3E38-4F0A-A8D7-6907099AF2FE)
            - 10.4.2 扩容集群 [📖](marginnote3app://note/76D8DBAC-F975-47F2-8EBF-7589C37DF9AE)
            - 10.4.3 收缩集群 [📖](marginnote3app://note/4CC15FEB-1EE9-41E5-96B0-2FB9A066A39E)
        - 10.5 请求路由 [📖](marginnote3app://note/E8D69312-87CC-48EB-8FF6-2856B57638C4)
            - 10.5.1 请求重定向 [📖](marginnote3app://note/7FCE4D97-AF22-4CD0-80A3-72C7CC259A25)
            - 10.5.2 Smart客户端 [📖](marginnote3app://note/1527B5CC-D12E-4A67-9AC9-9E9F18F64099)
            - 10.5.3 ASK重定向 [📖](marginnote3app://note/81C5C9E3-6373-4E45-8633-8DDF27F9D74C)
        - 10.6 故障转移 [📖](marginnote3app://note/BEFE6935-A0FA-4724-B880-3C7FBD225F60)
            - 10.6.1 故障发现 [📖](marginnote3app://note/D23744E8-DE63-46DA-B1CC-70EDC34FFFE2)
            - 10.6.2 故障恢复 [📖](marginnote3app://note/89D1241F-BB2F-4191-A9DD-DC3FBC8D65CD)
            - 10.6.3 故障转移时间 [📖](marginnote3app://note/F80B004E-B58D-4E38-95BA-EAD6D731E422)
            - 10.6.4 故障转移演练 [📖](marginnote3app://note/05872B61-B25C-4AD6-BFFA-6F2A10824308)
        - 10.7 集群运维 [📖](marginnote3app://note/04F7DE8A-F7F6-4FBC-AAC9-4FB22296EAC6)
            - 10.7.1 集群完整性 [📖](marginnote3app://note/6484E54B-1319-4315-A419-FE75B2766659)
            - 10.7.2 带宽消耗 [📖](marginnote3app://note/074AD703-C216-4A01-BDA8-E3480F5077A1)
            - 10.7.3 Pub/Sub广播问题 [📖](marginnote3app://note/281A01AB-201D-404C-A32E-D9277335922A)
            - 10.7.4 集群倾斜 [📖](marginnote3app://note/C9B33DBE-83F2-4D89-A226-F0EAE1C2B0EC)
            - 10.7.5 集群读写分离 [📖](marginnote3app://note/28B032CD-7D7B-4710-91A4-745611EF71EB)
            - 10.7.6 手动故障转移 [📖](marginnote3app://note/606A0110-9FF0-4314-812A-7B3CCC2551C2)
            - 10.7.7 数据迁移 [📖](marginnote3app://note/530AA510-7732-4171-8AF9-49E8E7FD99FF)
        - 10.8 本章重点回顾 [📖](marginnote3app://note/B34961B4-A6D8-44A3-B4D5-B4A3537AE104)
    - 第11章 缓存设计 [📖](marginnote3app://note/74CAE6B7-FDC2-4A07-85AD-5AF9ED65DAE6)
        - 11.1 缓存的收益和成本 [📖](marginnote3app://note/766F2B5C-BE50-4A81-91BB-6014F0C4150A)
        - 11.2 缓存更新策略 [📖](marginnote3app://note/CC4FFE7C-389F-4E68-ACDA-7694EA291989)
        - 11.3 缓存粒度控制 [📖](marginnote3app://note/239519F8-7EBA-47C5-95D4-F6496BB83455)
        - 11.4 穿透优化 [📖](marginnote3app://note/BBDD9146-C4C1-4CB1-8182-B052C7DF095A)
        - 11.5 无底洞优化 [📖](marginnote3app://note/278F03BD-9BE5-4257-B205-8E5A54B9EA2E)
        - 11.6 雪崩优化 [📖](marginnote3app://note/5275E876-6406-4723-AD0D-62E129581828)
        - 11.7 热点key重建优化 [📖](marginnote3app://note/FFEAD66F-A56E-4972-89A1-0B3E6CEC7D0C)
        - 11.8 本章重点回顾 [📖](marginnote3app://note/E9B5DC72-F34D-41E7-BF70-E1F4CDCCBEB3)
    - 第12章 开发运维的“陷阱” [📖](marginnote3app://note/7ED298E1-CF95-4B13-AEC0-67FB30B0DCA8)
        - 12.1 Linux配置优化 [📖](marginnote3app://note/D340567D-8D95-4B45-8C47-DD78CE8DFE4C)
            - 12.1.1 内存分配控制 [📖](marginnote3app://note/B9946780-0C36-449F-A949-80960288A0E2)
            - 12.1.2 swappiness [📖](marginnote3app://note/9DC1B0E5-484A-40E7-A7A3-1822CD19BF3F)
            - 12.1.3 THP [📖](marginnote3app://note/07C42088-905C-44E0-8BFF-037DFE5B3BA1)
            - 12.1.4 OOM killer [📖](marginnote3app://note/6E32EF6A-4946-447F-A77F-3546378BD1CE)
            - 12.1.5 使用NTP [📖](marginnote3app://note/62D92EBA-45E5-41A9-B986-2D72649C6834)
            - 12.1.6 ulimit [📖](marginnote3app://note/B2FAB6D2-E1BF-4EB6-B2E5-558658C77134)
            - 12.1.7 TCP backlog [📖](marginnote3app://note/8AFB0BAC-6355-4210-9246-4A06C1E899FA)
        - 12.2 flushall/flushdb误操作 [📖](marginnote3app://note/A27A39CD-E747-444F-B421-4E4CD7580E0B)
            - 12.2.1 缓存与存储 [📖](marginnote3app://note/F75F8202-5B2D-4BB9-930F-2896625F0427)
            - 12.2.2 借助AOF机制恢复 [📖](marginnote3app://note/927F3331-C32D-4316-B9BB-65079E809D32)
            - 12.2.3 RDB有什么变化 [📖](marginnote3app://note/1D09631D-3BEE-4504-B4D1-622B867F358C)
            - 12.2.4 从节点有什么变化 [📖](marginnote3app://note/E7F08BAA-1DD3-4B45-83A8-A0B36F96BBBB)
            - 12.2.5 快速恢复数据 [📖](marginnote3app://note/5782FF37-AC58-4D04-A494-03D392D7C258)
        - 12.3 安全的Redis [📖](marginnote3app://note/24813111-2B4B-4D41-AF53-87F9609561CF)
            - 12.3.1 Redis密码机制 [📖](marginnote3app://note/D83FC3E2-8A0F-4604-AAA3-4838152F8634)
            - 12.3.2 伪装危险命令 [📖](marginnote3app://note/203E0DE9-0C7B-4221-8748-06DF7CF22336)
            - 12.3.3 防火墙 [📖](marginnote3app://note/AAB9FF20-C0B7-469F-B5BB-FE3FD7FE4779)
            - 12.3.4 bind [📖](marginnote3app://note/8B1A7AC2-82DE-4F34-8769-7E0B18D244CB)
            - 12.3.5 定期备份数据 [📖](marginnote3app://note/ABF68721-FD51-4762-A242-9B9D751A7E45)
            - 12.3.6 不使用默认端口 [📖](marginnote3app://note/5D8EE774-4EB1-4144-A4E9-D8141E21E402)
            - 12.3.7 使用非root用户启动 [📖](marginnote3app://note/8224E9FE-B97C-455A-961B-B555DA420A1E)
        - 12.4 处理bigkey [📖](marginnote3app://note/CA85DD65-F32B-4C10-BFE1-7457B0820F64)
            - 12.4.1 bigkey的危害 [📖](marginnote3app://note/429DA222-A9CA-404A-A83B-84B04C5B83A3)
            - 12.4.2 如何发现 [📖](marginnote3app://note/BB6B24E0-E1C0-4FB9-8367-65273E2890F0)
            - 12.4.3 如何删除 [📖](marginnote3app://note/6FC3D8EE-F5DB-4D7C-ACB7-A518BB5DA706)
            - 12.4.4 最佳实践思路 [📖](marginnote3app://note/BDAC34C3-4366-44D5-9CF6-0D8A3227346E)
        - 12.5 寻找热点key [📖](marginnote3app://note/218AF48E-B13E-4E48-A580-1066490E2EF5)
        - 12.6 本章重点回顾 [📖](marginnote3app://note/FD0F9600-738C-4B05-B6D2-FE63B6BDD96F)
    - 第13章 Redis监控运维云平台CacheCloud [📖](marginnote3app://note/40A9949A-A668-40BD-9924-90AA15DC2E4D)
        - 13.1 CacheCloud是什么 [📖](marginnote3app://note/9BF1FDD5-1D98-44C2-B934-974E73F22FF0)
            - 13.1.1 现有问题 [📖](marginnote3app://note/757B6DB7-C2C6-4C75-8CAB-DDEF3C341B6F)
            - 13.1.2 CacheCloud基本功能 [📖](marginnote3app://note/7E7420A4-DEA2-482E-8AC1-BF34218ABBBD)
        - 13.2 快速部署 [📖](marginnote3app://note/73826ECB-6BE9-4159-A8C9-31BB33EAC704)
            - 13.2.1 CacheCloud环境需求 [📖](marginnote3app://note/ABB97AE6-68C8-43A7-B53B-EF89CBF89412)
            - 13.2.2 CacheCloud快速开始 [📖](marginnote3app://note/054067C4-881B-4240-B0F8-7DDC9E51DAA6)
        - 13.3 机器部署 [📖](marginnote3app://note/E0733D31-0060-4722-8589-D408CA552913)
            - 13.3.1 部署脚本 [📖](marginnote3app://note/800B2D25-EE97-4B2E-8AA9-03253EA55A21)
            - 13.3.2 添加机器 [📖](marginnote3app://note/2767B33E-8C39-4837-B884-27011C0238C5)
        - 13.4 接入应用 [📖](marginnote3app://note/234585BF-8825-4549-B7C2-4A9B8E569E16)
            - 13.4.1 总体流程 [📖](marginnote3app://note/E66D349D-124E-4E16-B2AC-32E3D12AE2DE)
            - 13.4.2 账户申请和审批 [📖](marginnote3app://note/5C24772B-7D6A-4DFE-9EED-06CFE6C5DDF1)
            - 13.4.3 应用申请和审批 [📖](marginnote3app://note/C3BFCA02-F9FE-45E2-85B3-4CBBCFCABA0A)
            - 13.4.4 客户端接入 [📖](marginnote3app://note/3935E031-18AE-4F05-86CD-AE94818CE043)
        - 13.5 用户功能 [📖](marginnote3app://note/C3F38F7C-C901-4B84-ABC9-42B5C37F3ABA)
            - 13.5.1 应用统计信息 [📖](marginnote3app://note/694FC1B0-DCDC-4BED-BD45-07D62DD31D33)
            - 13.5.2 实例列表 [📖](marginnote3app://note/B916B560-76BB-49F5-B337-BF7741B366BC)
            - 13.5.3 应用详情 [📖](marginnote3app://note/E6E25F65-BB22-4E65-A9B0-8868F12604E6)
            - 13.5.4 命令曲线 [📖](marginnote3app://note/11162EB0-4626-4E15-A63F-BF9C92D5DA21)
            - 13.5.5 CacheCloud Redis Shell控制台 [📖](marginnote3app://note/14E64720-4E21-4C56-BA3F-0CE4248D6C0B)
            - 13.5.6 慢查询 [📖](marginnote3app://note/108BC2BF-0906-42CB-9BA9-8A783B723B45)
            - 13.5.7 应用拓扑 [📖](marginnote3app://note/69ED3EE8-2649-43A8-A42E-8B33D1179952)
        - 13.6 运维功能 [📖](marginnote3app://note/D175F264-6D5C-45C2-8230-7111DA3D5702)
            - 13.6.1 应用运维 [📖](marginnote3app://note/F5D568FF-A347-4BA4-812C-A00CC0C77D4F)
            - 13.6.2 接入已存在的Redis节点 [📖](marginnote3app://note/8B341C07-6864-42CB-9F78-AA752EB9B476)
            - 13.6.3 Redis配置模板 [📖](marginnote3app://note/6651990E-63F2-4605-8F05-21431B435CC4)
            - 13.6.4 迁移工具 [📖](marginnote3app://note/D46EBA51-1347-4F86-95BB-087642EAB1CB)
            - 13.6.5 监控报警 [📖](marginnote3app://note/6C62E311-010D-4B24-8B8A-5B73FA973A89)
            - 13.6.6 系统配置管理 [📖](marginnote3app://note/A4E6821F-B811-44D6-A504-4FBB923E823F)
        - 13.7 客户端上报 [📖](marginnote3app://note/1BAB7960-8198-45F2-9939-94945EBC3C83)
            - 13.7.1 客户端上报整体设计 [📖](marginnote3app://note/8B05DCAC-3C9C-4B4B-991D-F1EBED146041)
            - 13.7.2 Jedis核心代码修改 [📖](marginnote3app://note/78035A81-9CFA-458C-A0DB-100114699533)
            - 13.7.3 带上报功能的客户端 [📖](marginnote3app://note/C56F9532-1579-488B-9C07-4FECFAC1EFD2)
            - 13.7.4 CacheCloud客户端统计 [📖](marginnote3app://note/057DC987-ACA1-4439-878F-A66A36EF8E7D)
        - 13.8 本章重点回顾 [📖](marginnote3app://note/22B69294-F98F-449A-9824-D9D6969B6539)
    - 第14章 Redis配置统计字典 [📖](marginnote3app://note/198E9758-24B5-4071-91CA-717916F9F951)
        - 14.1 info系统状态说明 [📖](marginnote3app://note/019266A9-59D8-4904-B960-F3D9D2DD2EAF)
            - 14.1.1 命令说明 [📖](marginnote3app://note/34932723-9956-4AFF-B3CF-7FCC2B96C03B)
            - 14.1.2 详细说明 [📖](marginnote3app://note/A509D9C0-9A77-4634-8D3F-4623347DFD99)
        - 14.2 standalone配置说明和分析 [📖](marginnote3app://note/EAB1BA86-7468-405B-A2B5-89B163B69883)
            - 14.2.1 总体配置 [📖](marginnote3app://note/962DAFDB-EFDD-469E-9356-F0010C5DEBF3)
            - 14.2.2 最大内存及策略 [📖](marginnote3app://note/000DE126-5BCA-4337-98C8-4045F07CACAE)
            - 14.2.3 AOF相关配置 [📖](marginnote3app://note/507DB3FF-38A5-4056-BC40-058F11303F1D)
            - 14.2.4 RDB相关配置 [📖](marginnote3app://note/8F4E9678-4ECF-481C-9605-4CEDA8EF3252)
            - 14.2.5 慢查询配置 [📖](marginnote3app://note/C316BFDC-2ABB-46BD-AABB-3C9872DAB41C)
            - 14.2.6 数据结构优化配置 [📖](marginnote3app://note/CCD99E3B-1914-47AA-AEBE-27BBA9870D01)
            - 14.2.7 复制相关配置 [📖](marginnote3app://note/148E9251-8AF8-42FF-AB1E-E1A6ACE10CD2)
            - 14.2.8 客户端相关配置 [📖](marginnote3app://note/C8E7543E-C70D-4DBF-BB11-EF982577CA31)
            - 14.2.9 安全相关配置 [📖](marginnote3app://note/AFB1682C-ED5F-419B-820A-BF09F583F588)
        - 14.3 Sentinel配置说明和分析 [📖](marginnote3app://note/85AD3898-07B7-4259-B517-28BF8DDE11F6)
        - 14.4 Cluster配置说明和分析 [📖](marginnote3app://note/0FD98833-4AEB-40E7-A5DD-C34F9365D95F)
