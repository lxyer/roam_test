- Redis设计与实现 [📖](marginnote3app://note/1B8EDC27-9CA5-485D-A373-427B5687A4AA)
    - 第一部分：内部数据结构 [📖](marginnote3app://note/EDC7496A-8386-435F-B50B-AA1EB4016247)
        - 简单动态字符串 [📖](marginnote3app://note/18D8FB33-4FC2-4A14-B61E-7BD6EA3CEC78)
            - sds 的用途 [📖](marginnote3app://note/4ADBE727-40E3-4591-AF9A-8B0FE76BE9E3)
                - Sds (**Simple Dynamic String,简单动态字符串**)是 Redis 底层所使用的字符串表示,它被用在几乎所有的 Redis 模块中。 [📖](marginnote3app://note/85A73B30-F3EB-42AE-9992-5B7AD5CE8E8C)
                - Sds 在 Redis 中的主要作用有以下两个: 1. 实现**字符串**对象(StringObject) ; 2. 在 Redis 程序内部用作 **char*** 类型的替代品; [📖](marginnote3app://note/A28966EE-2A65-4D69-BC56-77944160BB8A)
            - Redis 中的字符串 [📖](marginnote3app://note/3BED3295-604E-4EAF-9886-D4D584C143FA)
            - 优化追加操作 [📖](marginnote3app://note/C3074496-5479-49EB-B61D-CE5B4AAF3159)
                - sds 既可以高效地实现**追加**和**长度计算**,并且它还是**二进制**安全的 [📖](marginnote3app://note/67F40F43-FD13-462F-99D5-9DAF6ED7BBC7)
                - 结构 sdshdr 则保存了 len 、free 和 buf 三个属性。 [📖](marginnote3app://note/BE398893-FFBD-411A-B431-52EE8B116D29)
                    - 通过 len 属性,sdshdr 可以实现复杂度为 θ(1) 的长度计算操作 [📖](marginnote3app://note/35141BCF-1773-4C4B-A45D-1722A679FFD0)
                - 利用 sdshdr 结构,除了可以用 θ(1) 复杂度获取字符串的长度之外,还可以减少追加 (append) 操作所需的内存重分配次数 [📖](marginnote3app://note/EE03AFDD-8142-420D-9EC9-87E42F0E2D84)
            - sds 模块的 API [📖](marginnote3app://note/A17D1370-F8EE-45CB-B1EE-8C1BFFE48D78)
                - SDS_MAX_PREALLOC 的值为 1024 * 1024 ,也就是说,当大小小于1MB 的字符串执行追加操作时,sdsMakeRoomFor 就为它们分配多于所需大小一倍的空间;当字符串的大小大于 1MB ,那么 sdsMakeRoomFor 就为它们额外多分配 1MB 的空间。 [📖](marginnote3app://note/9E58EACA-A4B8-4087-AB93-25DDD6E22C65)
                - 字符串append这种预分配策略会浪费内存吗? [📖](marginnote3app://note/8A43F3E9-6652-4229-B137-452952AF2C5A)
                    - 执行过 APPEND 命令的字符串会带有额外的预分配空间,这些预分配空间不会被释放,除非该字符串所对应的键被删除,或者等到关闭 Redis 之后,再次启动时重新载入的字符串对象将不会有预分配空间。 [📖](marginnote3app://note/8F4FC080-CD2A-448A-94D2-378FF1A9CC53)
                    - 因为执行 APPEND 命令的字符串键数量通常并不多,占用内存的体积通常也不大,所以这一般并不算什么问题。 [📖](marginnote3app://note/9777B5F3-8939-4F95-AF5F-059C153992DF)
                    - [Redis](<Redis.md>) 对 sds 可以优化的点 [📖](marginnote3app://note/D1A88B6C-E521-4F89-BE7F-4A805B371A4C)
            - 小结 [📖](marginnote3app://note/BCC8262F-4714-4778-B2B8-B3CFEE982569)
        - 双端链表 [📖](marginnote3app://note/6D23877E-4F03-41B2-80B8-094FE43FBE96)
            - 双端链表的应用 [📖](marginnote3app://note/FB859B1F-3EEC-464A-9F76-59C8F71FBB05)
                - 双端链表还是 Redis 列表类型的底层实现之一 [📖](marginnote3app://note/DF5114B9-BE1D-4F8B-A95C-4201A0D52507)
                - 因为双端链表占用的内存比压缩列表要多,所以当创建新的列表键时,列表会优先考虑使用压缩列表作为底层实现,并且在有需要的时候,才从压缩列表实现转换到双端链表实现。 [📖](marginnote3app://note/84A74683-9852-4CA0-8196-8295E349585E)
                - 除了实现列表类型以外,双端链表还被很多 Redis 内部模块所应用: [📖](marginnote3app://note/85F759F4-16BA-4FB1-B6AE-AF336831B2FF)
                    - 事务模块使用双端链表来按顺序保存输入的命令; [📖](marginnote3app://note/3C0413FE-58A1-4B5A-B891-FA0B849974DF)
                    - 服务器模块使用双端链表来保存多个客户端; [📖](marginnote3app://note/7C153F88-B0EC-4CE9-98FC-8AEC4FF351BC)
                    - 订阅/发送模块使用双端链表来保存订阅模式的多个客户端; [📖](marginnote3app://note/45AE3417-3D6E-4931-B6F1-4D7F0DA7E8C9)
                    - 事件模块使用双端链表来保存时间事件(time event) ; [📖](marginnote3app://note/8C3B340B-3614-46B6-A4CC-A79FD8E2476B)
            - 双端链表的实现 [📖](marginnote3app://note/BEB0CADB-13AD-41D6-B2F5-9013498901F9)
                - 双端链表的实现由 listNode 和 list 两个数据结构构成 [📖](marginnote3app://note/FFB7E7C1-A40B-4013-B3D3-57A2890928B9)
            - 迭代器 [📖](marginnote3app://note/DAEB0877-6156-47D6-871C-5B0EB85FB63E)
            - 小结 [📖](marginnote3app://note/0BD097D8-AA8D-4BE5-B591-150EC3F34150)
                - 双端链表主要有两个作用: [📖](marginnote3app://note/D4E2A47E-5767-4E82-A8D1-3CF1297EF473)
                    - 作为 Redis 列表类型的底层实现之一; [📖](marginnote3app://note/F00BBFAE-4896-4180-A080-9C77880A8E90)
                    - 作为通用数据结构,被其他功能模块所使用; [📖](marginnote3app://note/15456DD7-39D4-41DF-96A2-D03AC02FC93E)
                - 双端链表及其节点的性能特性如下: [📖](marginnote3app://note/D1DD43CC-F43A-455D-96EA-456ABE2D9BDB)
                    - 节点带有前驱和后继指针,访问前驱节点和后继节点的复杂度为 O(1) ,并且对链表的迭代可以在从表头到表尾和从表尾到表头两个方向进行; [📖](marginnote3app://note/BE966126-C900-48BC-9861-E2C953DB7A71)
                    - 链表带有指向表头和表尾的指针,因此对表头和表尾进行处理的复杂度为 O(1) ; [📖](marginnote3app://note/0E3718F7-BE32-41C6-BD57-FC73AA1A59A9)
                    - 链表带有记录节点数量的属性,所以可以在 O(1) 复杂度内返回链表的节点数量(长度) ; [📖](marginnote3app://note/86BFF0B6-7F06-43D5-ACEB-2A21E76B30E5)
            - 对比 C 字符串,sds 有以下特性: [📖](marginnote3app://note/EFF255AF-6269-4FD4-AF88-9DE2EC2EBF69)
                - 可以高效地执行长度计算(strlen) ; [📖](marginnote3app://note/AC2DFC6C-3A15-4E50-9B20-9D28912D06D1)
                - 可以高效地执行追加操作(append) ; [📖](marginnote3app://note/E20E1AB6-E447-4650-B069-402D09D82EAF)
                - 二进制安全; [📖](marginnote3app://note/8AD4A84C-30EF-4A43-9385-FF03C7444661)
            - sds 会为追加操作进行优化:加快追加操作的速度,并降低内存分配的次数,代价是多占用了一些内存,而且这些内存不会被主动释放 [📖](marginnote3app://note/41DFEAAE-3377-4896-B453-B7D8CF0918EF)
        - 字典 [📖](marginnote3app://note/53FE6042-CB7B-4DEE-A2D5-2AA2713762AB)
            - 字典的应用 [📖](marginnote3app://note/CF16632B-DAB9-4801-928B-5C2480E76C46)
                - 字典(dictionary) ,又名映射(map)或关联数组(associative array) [📖](marginnote3app://note/DFBE7265-D10E-44D1-96B0-90A2AA9A0F5C)
                - 字典的主要用途有两个: [📖](marginnote3app://note/94456C52-72C0-4728-9D44-01EBDABF0D73)
                    - 实现数据库键空间(key space) ; [📖](marginnote3app://note/9FFBB4C7-FB29-42F5-A1B8-48C6D0B1E08E)
                        - 数据库中的键值对就由字典保存:每个数据库都有一个与之相对应的字典,这个字典被称之为键空间(key space) 。 [📖](marginnote3app://note/3ECD8CE6-3C8B-4280-8E7C-F9B2174D1A9C)
                        - 当用户添加一个键值对到数据库时(不论键值对是什么类型) ,程序就将该键值对添加到键空间;当用户从数据库中删除一个键值对时,程序就会将这个键值对从键空间中删除; [📖](marginnote3app://note/5621AEED-F821-4ABF-88DD-1390B3ED0803)
                    - 用作 Hash 类型键的其中一种底层实现; [📖](marginnote3app://note/430D556A-A4E1-4504-81EA-CBD0FB869AA7)
                - 执行 DBSIZE 则返回键空间上现有的键值对个数 [📖](marginnote3app://note/E25D110B-6077-4DA0-8C18-CCFCB4878BE1)
            - 字典的实现 [📖](marginnote3app://note/D8C6D725-7980-4345-8812-DDC3E77A9B3C)
                - Redis 选择了高效且实现简单的哈希表作为字典的底层实现 [📖](marginnote3app://note/63232117-BCE4-40E2-A8C7-8F524B920EAF)
                - table 属性是一个数组,数组的每个元素都是一个指向 dictEntry 结构的指针 [📖](marginnote3app://note/84A65FB0-9535-42CE-ACF7-2B3E1DB46053)
                - 每个 dictEntry 都保存着一个键值对,以及一个指向另一个 dictEntry 结构的指针 [📖](marginnote3app://note/94141710-7CB4-40B4-B273-2202EB54BC90)
                - next 属性指向另一个 dictEntry 结构,多个 dictEntry 可以通过 next 指针串连成链表,从这里可以看出,dictht 使用链地址法来处理键碰撞:当多个不同的键拥有相同的哈希值时,哈希表用一个链表将这些键连接起来。 [📖](marginnote3app://note/F35BADAA-EF7C-4FC7-8CAA-8D308FECD9CB)
                - 整个字典结构可以表示如下 [📖](marginnote3app://note/0316125D-A036-4126-BDCD-EDEE8A93CACC)
                    - dict type privdata ht[2] rehashidx: -1 iterators: 0 dictht table size: 4 sizemask: 3 used: 3 ht[0] dictht table size: 0 sizemask: 0 used: 0 ht[1] dictEntry** (bucket) 0123 NULL dictEntry key1value1next dictEntry key2value2next dictEntry key3value3next NULL NULL NULL NULL [📖](marginnote3app://note/249F9863-7859-41B3-9153-AF9B40ADAF6B)
                - 0 号哈希表(ht[0])是字典主要使用的哈希表,而 1 号哈希表(ht[1])则只有在程序对 0 号哈希表进行 rehash 时才使用 [📖](marginnote3app://note/A127BD46-2584-408C-B639-EBFB5990B32D)
            - 创建新字典 [📖](marginnote3app://note/FB1BE0F8-EACA-46B5-B7D6-ABE3D1EEC4DE)
                - 字典虽然创建了两个哈希表,但正在使用的只有 0 号哈希表,这说明字典未进行 rehash 状态 [📖](marginnote3app://note/EB785D17-2D37-429B-AAD0-377D3097685B)
                - Redis 目前使用两种不同的哈希算法 [📖](marginnote3app://note/0363DC51-B122-467A-B42C-8B897EB5C52C)
                    - MurmurHash2 32 bit 算法:这种算法的分布率和速度都非常好 [📖](marginnote3app://note/0AE42383-8C81-4C61-AAC0-77268D6E40F6)
                        - 算法 1 的应用则更加广泛:数据库、集群、哈希键、阻塞操作等功能都用到了这个算法 [📖](marginnote3app://note/9526C6D2-F63C-4AD5-9E50-98BD03002A27)
                    - 基 于djb 算 法 实 现 的 一 个 大 小 写 无 关 散 列 算 法 [📖](marginnote3app://note/C6592270-8F5F-42E8-B250-D18F63693661)
                        - 命令表以及 Lua 脚本缓存都用到了算法 2 [📖](marginnote3app://note/BA280B90-5E1E-43F9-90CA-55127D225304)
            - 添加键值对到字典 [📖](marginnote3app://note/A7A0DF7F-23E7-4D9D-B056-EC28FCD21638)
                - 根据字典所处的状态,将一个给定的键值对添加到字典可能会引起一系列复杂的操作 [📖](marginnote3app://note/68C9CB74-2406-4F4B-B354-396EA2FF2080)
                    - 如果字典为未初始化(也即是字典的 0 号哈希表的 table 属性为空) ,那么程序需要对 0 号哈希表进行初始化 [📖](marginnote3app://note/CAFFEC77-E4BC-4433-9D62-3CD467046D38)
                    - 如果在插入时发生了键碰撞,那么程序需要处理碰撞 [📖](marginnote3app://note/7531EA3B-195F-4E3A-B175-9E6FEA0A1A6C)
                    - 如果插入新元素使得字典满足了 rehash 条件,那么需要启动相应的 rehash 程序 [📖](marginnote3app://note/8F78994F-FBCD-4D3E-A00C-0BBD8259CDD0)
            - 添加新元素到空白字典 [📖](marginnote3app://note/1D98BE58-4214-416F-B9B9-B96D13708DE3)
            - 添加新键值对时发生碰撞处理 [📖](marginnote3app://note/DE9A93D9-C5F0-48BB-A00C-6410C7CD93CE)
                - 在哈希表实现中,当两个不同的键拥有相同的哈希值时,我们称这两个键发生碰撞 [📖](marginnote3app://note/0AD12F0D-4429-45BE-8178-10F9E0D8374A)
                - 字典哈希表所使用的碰撞解决方法被称之为链地址法:这种方法使用链表将多个哈希值相同的节点串连在一起,从而解决冲突问题。 [📖](marginnote3app://note/8CA11EDE-AAF4-4544-AFF1-6E0E9AB27108)
            - 添加新键值对时触发了 rehash 操作 [📖](marginnote3app://note/CE5BDE6A-5D81-49CA-A98E-F535AA8937FF)
                - 对于使用链地址法来解决碰撞问题的哈希表 dictht 来说, 哈希表的性能依赖于它的大小 (size 属性)和它所保存的节点的数量(used 属性)之间的比率 [📖](marginnote3app://note/5FB1C010-0A67-4FBA-AC97-062C6A8B7133)
                    - 比率在 1:1 时,哈希表的性能最好 [📖](marginnote3app://note/53141EEC-459D-4D4A-AB86-04D6E558722B)
                    - 如果节点数量比哈希表的大小要大很多的话,那么哈希表就会退化成多个链表,哈希表本身的性能优势就不再存在 [📖](marginnote3app://note/4C7625FD-B61E-4FBC-B5A5-402A1F7EFB0C)
            - Rehash 执行过程 [📖](marginnote3app://note/A94F994F-1206-47F6-B0A3-8EFBF955A0CA)
                - 为了在字典的键值对不断增多的情况下保持良好的性能,字典需要对所使用的哈希表(ht[0]) 进行 rehash 操作:在不修改任何键值对的情况下,对哈希表进行扩容,尽量将比率维持在 1:1 左右。 [📖](marginnote3app://note/240AC229-649B-4F5E-9019-A94163C7EBB2)
                - dictAdd 在每次向字典添加新键值对之前,都会对哈希表 ht[0] 进行检查,对于 ht[0] 的size 和 used 属性,如果它们之间的比率 ratio = used / size 满足以下任何一个条件的话, rehash 过程就会被激活 [📖](marginnote3app://note/290F5F83-1A30-4DB5-A363-23AAFF3F7B7A)
                    - 自然 rehash :ratio >= 1 ,且变量 dict_can_resize 为真 [📖](marginnote3app://note/8A7E0EE9-6870-4B87-8EA2-B919AD7815CC)
                    - 强 制 rehash : ratio 大 于 变 量 dict_force_resize_ratio (目 前 版 本 中, dict_force_resize_ratio 的值为 5 ) [📖](marginnote3app://note/19CA595F-A179-4218-B902-717C0D3BC057)
                - 什么时候 dict_can_resize 会为假? [📖](marginnote3app://note/752A6254-845B-49DC-95F3-29C1DD5D513B)
                    - 当 Redis 使用子进程对数据库执行后台持久化任务时(比如执行 BGSAVE 或 BGREWRITEAOF 时) , 为 了 最 大 化 地 利 用 系 统 的 copy on write 机 制, 程 序 会 暂 时 将dict_can_resize 设为假,避免执行自然 rehash ,从而减少程序对内存的触碰(touch) [📖](marginnote3app://note/DDBF5777-FBB3-4C6B-9091-87EA66FBD046)
                - 当字典满足了强制 rehash 的条件时,即使 dict_can_resize 不为真(有 BGSAVE 或 BGREWRITEAOF 正在执行) ,这个字典一样会被 rehash [📖](marginnote3app://note/E574EF7D-E139-4E5A-8727-B0BBC4F3CCB2)
                - 字典的 rehash 操作 [📖](marginnote3app://note/4FBB16A4-A43B-4A55-83FB-8D489B3A4E36)
                    - 1. 创建一个比 ht[0]->table 更大的 ht[1]->table [📖](marginnote3app://note/6AE81505-D23D-44B2-8187-2680A0B435EC)
                    - 2. 将 ht[0]->table 中的所有键值对迁移到 ht[1]->table [📖](marginnote3app://note/A626DF32-DADE-4AB8-9EC0-743AA8F71F73)
                    - 3. 将原有 ht[0] 的数据清空,并将 ht[1] 替换为新的 ht[0] [📖](marginnote3app://note/0367468D-4467-4786-A898-5A789FE32C30)
                - 开始 rehash [📖](marginnote3app://note/1291FFFE-17A1-4B07-B810-D4D171D247DE)
                    - 1. 设置字典的 rehashidx 为 0 ,标识着 rehash 的开始; [📖](marginnote3app://note/165C9613-F4FC-458A-AF29-374D8334ADB6)
                    - 2. 为 ht[1]->table 分配空间,大小至少为 ht[0]->used 的两倍; [📖](marginnote3app://note/AE57B11B-95D5-47BD-B0E1-132F3F9D641B)
                - Rehash 进行中 [📖](marginnote3app://note/93BEF2B2-4F30-4FD9-B0BC-253B0C1668EC)
                    - ht[0]->table 的节点会被逐渐迁移到 ht[1]->table [📖](marginnote3app://note/80532D33-F9D9-4DCA-8845-1AA2FBE1D9C2)
                - Rehash 完毕 [📖](marginnote3app://note/589D0913-22CD-44D7-8FBE-5034580BF846)
                    - 1. 释放 ht[0] 的空间; [📖](marginnote3app://note/A69693BF-8818-4DB1-810B-ABFCD336CAEB)
                    - 2. 用 ht[1] 来代替 ht[0] ,使原来的 ht[1] 成为新的 ht[0] ; [📖](marginnote3app://note/6CA76144-D321-47AD-B160-D1987EFC10DA)
                    - 3. 创建一个新的空哈希表,并将它设置为 ht[1] ; [📖](marginnote3app://note/C7DFC53A-0643-45B1-9759-F4FA6103C55C)
                    - 4. 将字典的 rehashidx 属性设置为 -1 ,标识 rehash 已停止; [📖](marginnote3app://note/A9B15047-0085-44AF-BD62-A5F86E6818BC)
            - 渐进式 rehash [📖](marginnote3app://note/252ABE19-5AD1-4AB4-AB6B-E7ED79D1658E)
                - 对比字典 rehash 之前和 rehash 之后,新的 ht[0] 空间更大,并且字典原有的键值对也没有被修改或者删除。 [📖](marginnote3app://note/708F61F5-E6DA-43A2-96D8-0C6C436A3CD8)
                - rehash 程序并不是在激活之后就马上执行直到完成的,而是分多次、渐进式地完成的 [📖](marginnote3app://note/CD376D9B-399D-4DAD-92B8-09CC9F10C541)
                - Redis 使用了渐进式(incremental)的 rehash 方式:通过将 rehash 分散到多个步骤中进行,从而避免了集中式的计算 [📖](marginnote3app://note/3D30F65B-3EE6-40E9-94E8-B48A67359043)
                - 在rehash 过程中,执行添加操作时,新的节点会直接添加到 ht[1] 而不是 ht[0] ,这样保证 ht[0] 的节点数量在整个 rehash 过程中都只减不增。 [📖](marginnote3app://note/683D3117-295F-4A04-9FA7-4DE9BF6CA42F)
            - 字典的收缩 [📖](marginnote3app://note/20DE1452-64BC-4B98-9AF3-F3AF96D215AD)
                - 如果哈希表的可用节点数比已用节点数大很多的话,那么也可以通过对哈希表进行 rehash 来收缩(shrink) 字典 [📖](marginnote3app://note/B3BE2B3F-F9E4-4A7E-9BC4-EA45B35723D6)
                - 收缩 rehash 和上面展示的扩展 rehash 的操作几乎一样 [📖](marginnote3app://note/EF5B1D83-E405-49FE-B7EA-5424D8E2A949)
                    - 1. 创建一个比 ht[0]->table 小的 ht[1]->table ; [📖](marginnote3app://note/B52439FA-CED2-442A-BF96-22DBD8CA0B69)
                    - 2. 将 ht[0]->table 中的所有键值对迁移到 ht[1]->table ; [📖](marginnote3app://note/75F57B3F-DD77-4F46-98D5-0DFE4142A389)
                    - 3. 将原有 ht[0] 的数据清空,并将 ht[1] 替换为新的 ht[0] ; [📖](marginnote3app://note/95DC21D2-1890-4838-9855-B9B9F4CF600E)
                - 默认情况下,当字典的填充率低于 10% 时,程序就可以对这个字典进行收缩操作了 [📖](marginnote3app://note/87CE0461-FBD1-4270-99B4-01476FEF7DB3)
                - 字典收缩和字典扩展的一个区别是 [📖](marginnote3app://note/A5291A88-9EF9-4CF6-989D-BB10279F269F)
                    - 字典的扩展操作是自动触发的(不管是自动扩展还是强制扩展) ; [📖](marginnote3app://note/EE7BCB05-7CDC-4036-9E71-62C91E86897C)
                    - 而字典的收缩操作则是由程序手动执行 [📖](marginnote3app://note/41960162-C920-4016-A9B7-067786B8187F)
            - 字典其他操作 [📖](marginnote3app://note/A24AC00F-7F42-4318-8BDE-D485F4577DDE)
            - 字典的迭代 [📖](marginnote3app://note/01DDEC05-2681-4300-A8D1-30331C8C7E56)
                - 字典的迭代器有两种: [📖](marginnote3app://note/31CF5E54-CFE7-4F18-AF4C-7B6B8774AD0A)
                    - 安全迭代器:在迭代进行过程中,可以对字典进行修改。 [📖](marginnote3app://note/68D870C4-1E5B-4533-BE00-AD93FB97FAFC)
                    - 不安全迭代器:在迭代进行过程中,不对字典进行修改。 [📖](marginnote3app://note/B5B2CE89-FE9B-46CC-944D-BD45C1DD56DD)
            - 小结 [📖](marginnote3app://note/DAC5B679-9190-4EA0-889B-849559EB3E01)
                - 字典由键值对构成的抽象数据结构。 [📖](marginnote3app://note/A0890DDA-2E9D-473C-9083-2E9A9FD476E2)
                - Redis 中的数据库和哈希键都基于字典来实现。 [📖](marginnote3app://note/EAC20003-CF79-4366-807C-0A241675E191)
                - Redis 字典的底层实现为哈希表,每个字典使用两个哈希表,一般情况下只使用 0 号哈希表,只有在 rehash 进行时,才会同时使用 0 号和 1 号哈希表。 [📖](marginnote3app://note/5FE45953-6658-439E-A0E7-6B0F2DA3F140)
                - 哈希表使用链地址法来解决键冲突的问题。 [📖](marginnote3app://note/59F1233F-60F6-4B97-9D3C-B99359005F53)
                - Rehash 可以用于扩展或收缩哈希表。 [📖](marginnote3app://note/03A79A30-4737-4B2F-AC7F-7E3DCD9289EB)
                - 对哈希表的 rehash 是分多次、渐进式地进行的。 [📖](marginnote3app://note/53784812-50DF-482F-8893-3537DADF9E49)
                - zzzzzzz [📖](marginnote3app://note/9A718F6A-3868-4BC5-BB09-93333C6051EF)
        - 跳跃表 [📖](marginnote3app://note/5A933354-5DBC-43CE-8393-AE574935D797)
            - 跳跃表的实现 [📖](marginnote3app://note/59B6B49E-79E2-413B-9A4B-3CDA16C88F6F)
                - 跳跃表主要由以下部分构成: [📖](marginnote3app://note/8956227A-9245-4517-8CC8-7A042966686F)
                    - 表头(head) :负责维护跳跃表的节点指针 [📖](marginnote3app://note/745F7D05-D70C-4754-9369-820FA74DA9E5)
                    - 跳跃表节点:保存着元素值,以及多个层 [📖](marginnote3app://note/9F925AB9-220C-404A-AA1C-8202A8794D6F)
                    - 层:保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针,为了提高查找的效率,程序总是从高层先开始访问,然后随着元素值范围的缩小,慢慢降低层次 [📖](marginnote3app://note/C821C69C-F244-4D5A-8CC5-BACFB4C7954C)
                    - 表尾:全部由 NULL 组成,表示跳跃表的末尾 [📖](marginnote3app://note/0DD191D9-083C-4086-8951-5397738A2092)
            - 跳跃表的应用 [📖](marginnote3app://note/5E20EE0F-CCE0-4E8C-8CD5-CC03D85DCD00)
            - 小结 [📖](marginnote3app://note/9861DA59-3C48-45EA-9CF7-BF8E7543D056)
                - 跳跃表是一种随机化数据结构,它的查找、添加、删除操作都可以在对数期望时间下完成。 [📖](marginnote3app://note/93AE280F-5E22-4564-B408-76B675122EE6)
                - 跳跃表目前在 Redis 的唯一作用就是作为有序集类型的底层数据结构(之一,另一个构成有序集的结构是字典) 。 [📖](marginnote3app://note/89767EB8-3665-404A-BF0F-27ABC47D6350)
                - 为了适应自身的需求,Redis 基于 William Pugh 论文中描述的跳跃表进行了修改 [📖](marginnote3app://note/5AFC4209-32C7-4A78-8A95-EA42C2BB8085)
                    - 1. score 值可重复。 [📖](marginnote3app://note/596EBFFC-C4D5-4663-B1DF-A36BC3AE49AF)
                    - 2. 对比一个元素需要同时检查它的 score 和 memeber 。 [📖](marginnote3app://note/C36F2482-DEDA-4B61-AA59-94900D5E41BD)
                    - 3. 每个节点带有高度为 1 层的后退指针,用于从表尾方向向表头方向迭代。 [📖](marginnote3app://note/46885616-A980-4887-8A8E-6D9993B8AC5D)
    - 第二部分：内存映射数据结构 [📖](marginnote3app://note/BF4B0BE6-6B6F-43B6-9BA4-817F5117D5AE)
        - 整数集合 [📖](marginnote3app://note/6E9FEE10-0AC4-4DD8-9F4E-C21EA38C08EF)
            - 整数集合的应用 [📖](marginnote3app://note/4EDDAA7B-A7FC-47FA-903C-85EE0C26F4D7)
            - 数据结构和主要操作 [📖](marginnote3app://note/1963A871-DEF4-4DCD-9841-804FB8306790)
            - intset 运行实例 [📖](marginnote3app://note/48A8927D-C1FC-4DE6-91A1-6D7F9EE39CB1)
            - 升级 [📖](marginnote3app://note/A53137FC-329E-49A3-800E-A7308D679BC8)
                - 当要添加新元素到 intset ,并且 intset 当前的编码并不适用于新元素的编码时,就需要对 inset 进行升级 [📖](marginnote3app://note/D679134B-C974-4EE5-9F08-4BB50EA68F62)
                - intsetUpgradeAndAdd 需要完成以下几个任务 [📖](marginnote3app://note/992B8579-E86A-4798-B592-7720DAF3061A)
                    - 1. 对新元素进行检测,看保存这个新元素需要什么类型的编码; [📖](marginnote3app://note/0D3651E5-E87E-43FE-9B47-7D0E8A86647A)
                    - 2. 将集合 encoding 属性的值设置为新编码类型,并根据新编码类型,对整个 contents 数组进行内存重分配。 [📖](marginnote3app://note/AB63F3B6-204F-43F9-AD9A-81B3F7181DDB)
                    - 3. 调整 contents 数组内原有元素在内存中的排列方式,让它们从旧编码调整为新编码。 [📖](marginnote3app://note/C19EF37B-2BE7-49A3-AEE0-B525A6B8E079)
                    - 4. 将新元素添加到集合中。 [📖](marginnote3app://note/795601B2-A295-4719-9D9A-D24D0A37098A)
            - 关于升级 [📖](marginnote3app://note/5E3D8C84-AB9E-4672-98EF-126F0C6BFA7A)
            - 关于元素移动 [📖](marginnote3app://note/2CD0D9EA-C672-4CF0-AEE4-DFF954CB21F8)
            - 其他操作 [📖](marginnote3app://note/81396CBB-1B99-4330-979B-532269CB6A1C)
                - intset 只进行从较短整数到较长整数的转换(也即是,只“升级” ,不“降级” ) [📖](marginnote3app://note/9ECD3408-056D-4F5A-9B49-3523DC2AA8B3)
                - 集合编码元素的类型,由元素中长度最大的那个值来决定 [📖](marginnote3app://note/58F57FFC-6AB0-4919-AC3D-60399AA6A66C)
            - 小结 [📖](marginnote3app://note/5EA25250-67B2-4819-9D7A-A5688A87584E)
                - Intset 用于有序、无重复地保存多个整数值,它会根据元素的值,自动选择该用什么长度的整数类型来保存元素。 [📖](marginnote3app://note/32B77CEA-0FFD-4E18-A065-70C70213A722)
                - 当一个位长度更长的整数值添加到 intset 时,需要对 intset 进行升级,新 intset 中每个元素的位长度都等于新添加值的位长度,但原有元素的值不变。 [📖](marginnote3app://note/AAEBB7E2-A125-430F-BC8D-1F89A2DC65BC)
                - 升级会引起整个 intset 进行内存重分配,并移动集合中的所有元素,这个操作的复杂度为 O(N) 。 [📖](marginnote3app://note/35EEAC54-8106-4AE2-94B7-86B4AB6CD0A6)
                - Intset 只支持升级,不支持降级。 [📖](marginnote3app://note/C5548BAE-3ED4-4A73-A292-4DE768632CFD)
                - Intset 是有序的,程序使用二分查找算法来实现查找操作,复杂度为 O(lg N) 。 [📖](marginnote3app://note/26F59000-8F2D-488A-B70F-B7618CE038D4)
            - 整数集合(intset)用于有序、无重复地保存多个整数值,它会根据元素的值,自动选择该用什么长度的整数类型来保存元素 [📖](marginnote3app://note/3B6CD4B5-6E66-49AA-A26A-D665BB826082)
            - 如果在一个 intset 里面,最长的元素可以用 int16_t 类型来保存,那么这个 intset 的所有元素都以 int16_t 类型来保存 [📖](marginnote3app://note/70B4B72E-2D5C-4154-9CF5-C3610A137EF1)
            - 如果有一个新元素要加入到这个 intset ,如果原类型太小无法保存,那么这个 intset 就会自动进行“升级” :先将集合中现有的所有元素从 int16_t 类型转换为 int32_t 类型,接着再将新元素加入到集合中 [📖](marginnote3app://note/0EE9E4B9-25B6-416D-B77F-8C98B4313D04)
        - 压缩列表 [📖](marginnote3app://note/8D1328E0-19C8-4C99-AC56-1722FC66E096)
            - ziplist 的构成 [📖](marginnote3app://note/47610052-E70B-4AB2-8169-663491ED667E)
            - 节点的构成 [📖](marginnote3app://note/B1FE3D04-7A14-4B13-B74B-86B8380313F1)
            - 创建新 ziplist [📖](marginnote3app://note/84163C77-3411-4B23-A2FA-999277B88792)
            - 将节点添加到末端 [📖](marginnote3app://note/268A5E25-D38E-4F3F-888B-AF0A7F0A0AC0)
                - 将新节点添加到 ziplist 的末端需要执行以下四个步骤 [📖](marginnote3app://note/51A942B3-AF2C-4EB2-96A3-F982CEB7085D)
                    - 1. 记录到达 ziplist 末端所需的偏移量(因为之后的内存重分配可能会改变 ziplist 的地址, 因此记录偏移量而不是保存指针) [📖](marginnote3app://note/7EF61113-D1F8-44B4-8607-6F60E50F4A9B)
                    - 2. 根据新节点要保存的值,计算出编码这个值所需的空间大小,以及编码它前一个节点的长度所需的空间大小,然后对 ziplist 进行内存重分配。 [📖](marginnote3app://note/35EA4687-7B06-4438-91AF-1D4209C89A78)
                    - 3. 设置新节点的各项属性:pre_entry_length 、encoding 、length 和 content 。 [📖](marginnote3app://note/C70052AE-167D-4430-AABF-D76CA128787A)
                    - 4. 更新 ziplist 的各项属性,比如记录空间占用的 zlbytes ,到达表尾节点的偏移量 zltail ,以及记录节点数量的 zllen 。 [📖](marginnote3app://note/B42A10E5-F384-4AD5-B060-054964F6E27A)
            - 将节点添加到某个/某些节点的前面 [📖](marginnote3app://note/42C474A4-27AF-43C2-9ED2-0229382C3BE8)
            - 删除节点 [📖](marginnote3app://note/2B3A0B2E-D499-436F-B377-E307648D2DBE)
            - 遍历 [📖](marginnote3app://note/D3A3D7B3-9B12-461F-AA11-C42B6E58CE00)
            - 查找元素、根据值定位节点 [📖](marginnote3app://note/848158C4-B360-45BC-B384-6D94D1D62CB0)
            - 小结 [📖](marginnote3app://note/5AADB8EA-65AF-48F2-B6E1-6E973F4E985A)
                - ziplist 是由一系列特殊编码的内存块构成的列表,它可以保存字符数组或整数值,它还是哈希键、列表键和有序集合键的底层实现之一。 [📖](marginnote3app://note/DCD556E6-0CA0-472C-B146-B0A60217BCAC)
                - 添加和删除 ziplist 节点有可能会引起连锁更新,因此,添加和删除操作的最坏复杂度为O(N2) ,不过,因为连锁更新的出现概率并不高,所以一般可以将添加和删除操作的复杂度视为 O(N) 。 [📖](marginnote3app://note/6EDB84A9-EDA7-415C-912B-8717B5BA9D5F)
            - Ziplist 是由一系列特殊编码的内存块构成的列表,一个 ziplist 可以包含多个节点(entry) ,每个节点可以保存一个长度受限的字符数组(不以 \0 结尾的 char 数组)或者整数 [📖](marginnote3app://note/8D6C91A4-B294-472D-BC6A-E3FA77D5A9C6)
            - 因为 ziplist 节约内存的性质,它被哈希键、列表键和有序集合键作为初始化的底层实现来使用 [📖](marginnote3app://note/41F7A340-72DA-41C6-ADA3-F674232E2935)
    - 第三部分：Redis 数据类型 [📖](marginnote3app://note/DACDDB9F-1BC4-44C4-B1B3-05CB5316E25B)
        - 对象处理机制 [📖](marginnote3app://note/6D81D445-85B2-41DE-ADD7-9DD5F392FDCD)
            - redisObject 数据结构，以及 Redis 的数据类型 [📖](marginnote3app://note/F9C2CD78-0556-48EA-BEF9-A272BBBD8DB9)
            - 命令的类型检查和多态 [📖](marginnote3app://note/7F97913A-A466-4B0C-8206-0C8302D4759B)
            - 对象共享 [📖](marginnote3app://note/1D8164D8-29F8-4C9D-89A8-BE5A94C6655D)
            - 引用计数以及对象的销毁 [📖](marginnote3app://note/0B2C3045-77D0-456D-A8EF-2035A7C75FBE)
                - Redis 的对象系统使用了引用计数技术来负责维持和销毁对象 [📖](marginnote3app://note/A35D20EB-B634-46C5-87F7-14AB754ABC12)
            - 小结 [📖](marginnote3app://note/CF9A8597-7823-46AF-8555-C6A93B2D856D)
        - 字符串 [📖](marginnote3app://note/51B473EC-BB5D-43BE-804C-42948AF32A07)
            - 字符串编码 [📖](marginnote3app://note/7D43524A-1A4F-4A3B-B303-20490BFA8192)
                - 每个 redisObject 结构都带有一个 refcount 属性,指示这个对象被引用了多少次。 [📖](marginnote3app://note/D48A42EF-8B6E-47DF-849D-353BD46CEC4F)
                - 当新创建一个对象时,它的 refcount 属性被设置为 1 。 [📖](marginnote3app://note/DDC00E42-CD63-4379-B00C-2728D6E1DC04)
                - 当对一个对象进行共享时,Redis 将这个对象的 refcount 增一。 [📖](marginnote3app://note/140EFDB7-A432-4AAB-A83A-B11CCC238454)
                - 当使用完一个对象之后,或者取消对共享对象的引用之后,程序将对象的 refcount 减一。 [📖](marginnote3app://note/F15267AB-8EF4-482A-AD75-1BDC04179C95)
                - 当对象的 refcount 降至 0 时,这个 redisObject 结构,以及它所引用的数据结构的内存,都会被释放。 [📖](marginnote3app://note/9AF49C5F-8C9B-42C5-A1FA-D24BCA361DF8)
            - 编码的选择 [📖](marginnote3app://note/A9CB7BE6-DC69-4D19-8026-131B9F5225E6)
            - 字符串命令的实现 [📖](marginnote3app://note/CF71FD0A-3173-4BF0-B9E4-03CBA2635659)
        - 哈希表 [📖](marginnote3app://note/A1696995-2237-432B-BA50-AD6988C09652)
            - 字典编码的哈希表 [📖](marginnote3app://note/8A6823C6-7966-45F1-9E05-324B708D4021)
            - 压缩列表编码的哈希表 [📖](marginnote3app://note/1A355A4F-BEC2-40B1-B6B6-EC742B0365C5)
            - 编码的选择 [📖](marginnote3app://note/FA774A5C-5C68-4387-A99C-A514A7EA64FA)
            - 哈希命令的实现 [📖](marginnote3app://note/13D40290-7149-450E-902F-0012C7135AB1)
        - 列表 [📖](marginnote3app://note/FFF69BE1-E530-4CD0-BE82-3EC9C474062A)
            - 编码的选择 [📖](marginnote3app://note/8989AB17-8D63-4AB1-9D4F-DB33706ED61C)
            - 列表命令的实现 [📖](marginnote3app://note/0F20AAE6-EED3-48CC-B638-0A9D44A99C67)
            - 阻塞的条件 [📖](marginnote3app://note/74CD56F6-FCB7-4214-8DEB-DFEA4CEFD222)
            - 阻塞 [📖](marginnote3app://note/8BEF3461-9A35-4A3D-8F65-CEED4D5277CB)
            - 阻塞因 LPUSH 、 RPUSH 、 LINSERT 等添加命令而被取消 [📖](marginnote3app://note/5D09E68B-7AC4-423D-A446-CE9618B69792)
            - 先阻塞先服务（FBFS）策略 [📖](marginnote3app://note/3D54969D-B38D-4248-87DB-B35A606FFFFA)
            - 阻塞因超过最大等待时间而被取消 [📖](marginnote3app://note/FE938BDE-B66B-4652-99F1-480F70CB4BE6)
            - 新添加的 key-value 对会被添加到压缩列表的表尾 [📖](marginnote3app://note/4413CF35-BCF9-4F32-9B46-8F80C8F69A0F)
        - 集合 [📖](marginnote3app://note/34DD2305-3223-43E7-B2CF-7363ABF3D634)
            - 编码的选择 [📖](marginnote3app://note/94FF027F-C331-43A8-8FA9-AB32AD4A99D4)
            - 编码的切换 [📖](marginnote3app://note/3DE282F6-001C-49E2-8E82-39A0FE99E2BD)
            - 字典编码的集合 [📖](marginnote3app://note/0134D788-C782-40A1-92BE-5A388965E6A0)
            - 集合命令的实现 [📖](marginnote3app://note/3E79134C-4659-4861-9223-7C8507E899B8)
            - 求交集算法 [📖](marginnote3app://note/E92B8154-8CA7-4A54-9CCB-2A1BEA9BF4FE)
            - 求并集算法 [📖](marginnote3app://note/098EBBD9-22E8-4634-9D06-4FBB9EB454E9)
            - 求差集算法 [📖](marginnote3app://note/DC3D87EE-45B5-426E-8266-6CB9A02266F9)
        - 有序集 [📖](marginnote3app://note/7B169819-4B02-478C-9741-4360988942FD)
            - 编码的选择 [📖](marginnote3app://note/AB7831FF-AFF1-4031-844B-43CAB0CFF0D6)
            - 编码的转换 [📖](marginnote3app://note/1BDD2081-21C0-4963-A871-6BD5F83F64B0)
            - ZIPLIST 编码的有序集 [📖](marginnote3app://note/5D87E261-405C-425D-8D6A-6AA56F09011D)
                - 在通过 ZADD 命令添加第一个元素到空 key 时,程序通过检查输入的第一个元素来决定该创建什么编码的有序集。 [📖](marginnote3app://note/AB6ADC6B-8291-4A49-94DA-8299F32F4DAB)
            - SKIPLIST 编码的有序集 [📖](marginnote3app://note/BFAEE6EE-CF8D-47CE-B59F-71DAD74FF5DD)
    - 第四部分：功能的实现 [📖](marginnote3app://note/73BC3906-BF31-4D93-81B8-D4A29DA16E5B)
        - 事务 [📖](marginnote3app://note/8374A413-33BE-4C2A-9DEA-E5BB6B35C223)
            - 事务 [📖](marginnote3app://note/2D7A471A-6D8D-4AD7-A8EC-DBC8453101EF)
            - 开始事务 [📖](marginnote3app://note/69149904-588F-4786-84FA-B8197D95FAAA)
                - MULTI 命令的执行标记着事务的开始 [📖](marginnote3app://note/390EC334-A9B3-4602-9191-E19BCF059AB6)
                - MULTI命令唯一做的就是,将客户端的 REDIS_MULTI 选项打开,让客户端从非事务状态切换到事务状态。 [📖](marginnote3app://note/3C806A2C-D7F4-4D78-A3FA-B984E4F80C1B)
                - 一个事务从开始到执行会经历以下三个阶段 [📖](marginnote3app://note/69EBB516-4FFE-439B-BC5A-E945503EA753)
                    - 1. 开始事务。 [📖](marginnote3app://note/4E820B7D-F430-4F9E-9382-97F45C9901FD)
                    - 2. 命令入队。 [📖](marginnote3app://note/374C30B9-2208-44DF-B8B3-BF26E5189EB3)
                    - 3. 执行事务。 [📖](marginnote3app://note/2AEADC11-0970-4C37-807A-FBC1DC91AC47)
            - 命令入队 [📖](marginnote3app://note/E262A842-DAA3-4BEB-8280-E2F194E9F1F1)
            - 执行事务 [📖](marginnote3app://note/1A1EC8C8-C253-42C8-9089-5F9E624C8FCA)
            - 在事务和非事务状态下执行命令 [📖](marginnote3app://note/58D3E88A-8948-46F0-8487-A09B95EDFE6F)
            - 事务状态下的 DISCARD 、 MULTI 和 WATCH 命令 [📖](marginnote3app://note/42A93C11-7B6D-4FC2-A1B9-3772F20BBD01)
            - 带 WATCH 的事务 [📖](marginnote3app://note/11FA2708-DC28-412F-BF6D-49F5B46298B5)
            - WATCH 命令的实现 [📖](marginnote3app://note/3A761C73-B26A-4E71-8FE2-511777B76392)
                - DISCARD 命令用于取消一个事务,它清空客户端的整个事务队列,然后将客户端从事务状态调整回非事务状态 [📖](marginnote3app://note/2D6119AA-DBC0-42E8-AC0B-10DE302F718D)
                - Redis 的事务是不可嵌套的,当客户端已经处于事务状态,而客户端又再向服务器发送 MULTI 时,服务器只是简单地向客户端发送一个错误,然后继续等待其他命令的入队。 [📖](marginnote3app://note/FF2DD5F6-10EF-4071-B424-548B8308420E)
            - WATCH 的触发 [📖](marginnote3app://note/F41E7D4A-9FF5-4836-A044-05C9C57A898A)
            - 事务的 ACID 性质 [📖](marginnote3app://note/89727827-7CCA-4749-A1B6-C873570B4CB1)
                - Redis 没有在事务上增加任何维持原子性的机制 [📖](marginnote3app://note/8E484AF0-3BD0-4CC7-96E9-F2FA07FEEE9E)
                - 当事务失败时,Redis 也不会进行任何的重试或者回滚动作 [📖](marginnote3app://note/45002319-D030-4C82-A2F6-4962BAE9E27D)
            - 小结 [📖](marginnote3app://note/736B7A89-035F-431B-9256-5E571AD21C34)
                - 事务提供了一种将多个命令打包,然后一次性、有序地执行的机制。 [📖](marginnote3app://note/8B809F60-BDA1-4FEF-BC9E-FDD236775693)
                - 事务在执行过程中不会被中断,所有事务命令执行完之后,事务才能结束。 [📖](marginnote3app://note/FEC545B1-189A-4B9F-A67D-7323968CA98C)
                - 多个命令会被入队到事务队列中,然后按先进先出(FIFO)的顺序执行。 [📖](marginnote3app://note/80416CC6-E664-493F-80DA-797E8E4DD311)
                - 带 WATCH 命令的事务会将客户端和被监视的键在数据库的 watched_keys 字典中进行关联,当键被修改时,程序会将所有监视被修改键的客户端的 REDIS_DIRTY_CAS 选项打开。 [📖](marginnote3app://note/A03668E1-C59C-409A-94D2-6B31DF36300C)
                - 只有在客户端的 REDIS_DIRTY_CAS 选项未被打开时,才能执行事务,否则事务直接返回失败。 [📖](marginnote3app://note/E449D211-32CD-400D-B66D-769A5CFD1E73)
                - Redis 的事务保证了 ACID 中的一致性(C)和隔离性(I) ,但并不保证原子性(A)和持久性(D) 。 [📖](marginnote3app://note/A5C8DB2C-5681-4AF4-ADC9-B5831A0B57AD)
        - 订阅与发布 [📖](marginnote3app://note/F315B972-853D-4990-89CC-701EC45E8A91)
            - 频道的订阅与信息发送 [📖](marginnote3app://note/C0DC705D-6F3F-4FBD-B820-693ED27EAD4A)
            - 订阅频道 [📖](marginnote3app://note/11357104-84A8-4DDA-AAFB-172C5331295C)
            - 发送信息到频道 [📖](marginnote3app://note/C9110CAA-E43B-42DA-BF75-D544530263EC)
            - 退订频道 [📖](marginnote3app://note/6F916973-0F9D-461F-843D-BB58A9804123)
            - 模式的订阅与信息发送 [📖](marginnote3app://note/9A35D303-E660-4561-9571-7ED7202383D6)
            - 订阅模式 [📖](marginnote3app://note/6ACCAC86-F65A-4391-9A43-F241EB79F8CC)
            - 发送信息到模式 [📖](marginnote3app://note/4243EF53-43E6-4625-A2D3-02DB46E470EB)
            - 退订模式 [📖](marginnote3app://note/5FB29801-CA79-46E9-9FE9-546329516196)
            - 小结 [📖](marginnote3app://note/A63B3D8F-2A05-4E09-83D3-00804B88D3BB)
                - 订阅信息由服务器进程维持的 redisServer.pubsub_channels 字典保存,字典的键为被订阅的频道,字典的值为订阅频道的所有客户端。 [📖](marginnote3app://note/6CCF2E53-A05F-49B9-A6A3-631C9DC0589C)
                - 当有新消息发送到频道时,程序遍历频道(键)所对应的(值)所有客户端,然后将消息发送到所有订阅频道的客户端上。 [📖](marginnote3app://note/35A842F8-79FE-4089-837D-C482E80CE854)
                - 订阅模式的信息由服务器进程维持的 redisServer.pubsub_patterns 链表保存,链表的每个节点都保存着一个 pubsubPattern 结构,结构中保存着被订阅的模式,以及订阅该模式的客户端。程序通过遍历链表来查找某个频道是否和某个模式匹配。 [📖](marginnote3app://note/E2E3863F-4292-425D-97D7-2C63B70A0F18)
                - 当有新消息发送到频道时,除了订阅频道的客户端会收到消息之外,所有订阅了匹配频道的模式的客户端,也同样会收到消息。 [📖](marginnote3app://note/5EA0C2C0-B8C6-40A7-9CDF-E26E95F78665)
                - 退订频道和退订模式分别是订阅频道和订阅模式的反操作。 [📖](marginnote3app://note/63495E19-7530-4F14-B5D7-7C93B4F3BA8B)
        - Lua 脚本 [📖](marginnote3app://note/194B2BF3-B2BC-4DFD-9602-3D2CBA2E2FAC)
            - 初始化 Lua 环境 [📖](marginnote3app://note/C4ABC14B-22E2-4CEE-B65D-159A742D7C98)
            - 脚本的安全性 [📖](marginnote3app://note/20AC3D03-DF5D-42FC-B95C-02B3CF31A0E0)
            - 脚本的执行 [📖](marginnote3app://note/6F719AD5-7D67-4A81-9087-11AFDF2089A6)
            - EVAL 命令的实现 [📖](marginnote3app://note/B65B5ACB-A115-4B62-9FB6-B002C89AE3D8)
            - EVALSHA 命令的实现 [📖](marginnote3app://note/D2247658-010C-4BA1-8C4D-98ED1D306CC3)
            - 小结 [📖](marginnote3app://note/91C5A4B8-0A17-4A2B-9CD5-A2CB22601663)
        - 慢查询日志 [📖](marginnote3app://note/13A5CBE8-6CF5-453D-8B40-DD8E899EDD27)
            - 相关数据结构 [📖](marginnote3app://note/7EDB34EF-F745-488E-BE15-6B2DA16DD766)
            - 慢查询日志的记录 [📖](marginnote3app://note/E285FF02-081A-4B66-B6A2-8ED7AA4B9DF7)
            - 慢查询日志的操作 [📖](marginnote3app://note/D6D0E682-64E9-468A-B9BB-153594AA4D6A)
            - 小结 [📖](marginnote3app://note/F3DEB04E-2B5F-4FC0-A2A3-A25B9A091B34)
    - 第五部分：内部运作机制 [📖](marginnote3app://note/48C8BAA1-3FB5-4233-BB8B-950970807D58)
        - 数据库 [📖](marginnote3app://note/57E47E8E-8D56-4003-B170-37AB2BB52C56)
            - 数据库的结构 [📖](marginnote3app://note/44149726-A0DC-4A0B-9DC3-A71A4A9CCCA4)
            - 数据库的切换 [📖](marginnote3app://note/8E0BAE9D-13E1-4EAC-B6C0-C7E50E348E4E)
            - 数据库键空间 [📖](marginnote3app://note/413EAEB2-4851-41AD-96CE-BF0F7ED56FF5)
            - 键空间的操作 [📖](marginnote3app://note/57E498E5-0BAA-43F6-A476-BC207DFFE6BA)
            - 键的过期时间 [📖](marginnote3app://note/08A865DB-3F38-400F-BB92-16C617AE80B0)
            - 过期时间的保存 [📖](marginnote3app://note/78CDAC6E-0858-48BC-AA4A-D16B370142BB)
            - 设置生存时间 [📖](marginnote3app://note/CE6A0EC9-8902-4357-9A28-10BCED66773B)
            - 过期键的判定 [📖](marginnote3app://note/77AD250D-508E-4B53-809A-797A6CD6034B)
            - 过期键的清除 [📖](marginnote3app://note/097AC13D-BEC9-4C1E-9839-46EB43EB60DF)
                - 通过 expires 字典,可以用以下步骤检查某个键是否过期: [📖](marginnote3app://note/CE898F25-9759-4449-A7C3-3F4E5D1E6D6E)
                    - 1. 检查键是否存在于 expires 字典:如果存在,那么取出键的过期时间; [📖](marginnote3app://note/99BC9561-84B6-42DF-A8E7-15EC510CD9AC)
                    - 2. 检查当前 UNIX 时间戳是否大于键的过期时间:如果是的话,那么键已经过期;否则, 键未过期。 [📖](marginnote3app://note/FEB5B1F2-33CA-4341-B42E-07508ACFF6EF)
                - 三种删除方式 [📖](marginnote3app://note/8C1D7BF5-4FB4-46D7-8B13-5D3A1270D78F)
                    - 1. 定时删除:在设置键的过期时间时,创建一个定时事件,当过期时间到达时,由事件处理器自动执行键的删除操作。 [📖](marginnote3app://note/183745B0-199B-46DA-A124-1D724C7FC721)
                        - 定时删除策略对内存是最友好的:因为它保证过期键会在第一时间被删除,过期键所消耗的内存会立即被释放。 [📖](marginnote3app://note/60703030-B297-4224-B360-54E068F9D2E3)
                        - 这种策略的缺点是,它对 CPU 时间是最不友好的:因为删除操作可能会占用大量的 CPU 时间 [📖](marginnote3app://note/234FC31F-4EAB-4152-91F5-31A65E188DFE)
                    - 2. 惰性删除:放任键过期不管,但是在每次从 dict 字典中取出键值时,要检查键是否过期,如果过期的话,就删除它,并返回空;如果没过期,就返回键值。 [📖](marginnote3app://note/828FE420-8F64-4D9B-8267-D49EB8C0F98D)
                        - 惰性删除对 CPU 时间来说是最友好的:它只会在取出键时进行检查,这可以保证删除操作只会在非做不可的情况下进行 [📖](marginnote3app://note/7A3FB264-9C61-4A63-A9F3-0C941B573736)
                        - 惰性删除的缺点是,它对内存是最不友好的 [📖](marginnote3app://note/57CDD010-BB8A-4F93-8928-C67EB51CE9FA)
                    - 3. 定期删除:每隔一段时间,对 expires 字典进行检查,删除里面的过期键。 [📖](marginnote3app://note/10140288-051F-4E95-A726-E527C1B1D798)
                        - 它每隔一段时间执行一次删除操作,并通过限制删除操作执行的时长和频率,籍此来减少删除操作对 CPU 时间的影响。 [📖](marginnote3app://note/2F3EF61B-F5F4-4B0E-A6E8-313A2951B125)
                        - 另一方面,通过定期删除过期键,它有效地减少了因惰性删除而带来的内存浪费。 [📖](marginnote3app://note/512B94D1-A200-4A4B-94A3-B2DD4799CB01)
            - 过期键的惰性删除策略 [📖](marginnote3app://note/453D8C94-5113-4D2E-9360-FCFC42CB58F6)
            - 过期键的定期删除策略 [📖](marginnote3app://note/8111B314-CC68-4487-B381-903D763C5A4C)
            - 过期键对 AOF 、RDB 和复制的影响 [📖](marginnote3app://note/A3F9B780-CA85-480B-A0C4-D33471BAB19B)
            - 数据库空间的收缩和扩展 [📖](marginnote3app://note/C5CCA50E-59E7-42DB-A6A7-E10A516453F7)
                - 在创建新的 RDB 文件时,程序会对键进行检查,过期的键不会被写入到更新后的 RDB 文件中。 [📖](marginnote3app://note/6501E74C-3132-4DA6-BA95-9F81D63A3DFA)
                - 过期键对更新后的 RDB 文件没有影响 [📖](marginnote3app://note/796F4AB2-92C0-4742-B2C3-D1523F47E66B)
                - 过期 key 对 aof 文件的影响 [📖](marginnote3app://note/BF47F692-68F9-4917-ACC6-35E5A0124E5C)
                    - 1. 从数据库中删除 message ; [📖](marginnote3app://note/14111385-F904-4ABC-972D-06EF4A783C5A)
                    - 2. 追加一条 DEL message 命令到 AOF 文件; [📖](marginnote3app://note/6606BD19-7FA3-4A2D-9A14-19C28F38DA4C)
                    - 3. 向客户端返回 NIL 。 [📖](marginnote3app://note/463AD280-80DF-45FD-B08C-165EA1E93241)
                - 当进行 AOF 重写时,程序会对键进行检查,过期的键不会被保存到重写后的 AOF 文件。 [📖](marginnote3app://note/E7C22B52-C1BB-4F62-95AF-06BD8E4B44AE)
            - 小结 [📖](marginnote3app://note/9462D0C1-3367-469D-B21E-8B2D051128BE)
                - expires 的某个键和 dict 的某个键共同指向同一个字符串对象,而 expires 键的值则是该键以毫秒计算的 UNIX 过期时间戳。 [📖](marginnote3app://note/CCB608F6-7B6C-4611-AE84-B6359D556062)
                - Redis 使用惰性删除和定期删除两种策略来删除过期的键。 [📖](marginnote3app://note/D426B99F-3B60-4944-9E83-A097C4FBFFF6)
                - 更新后的 RDB 文件和重写后的 AOF 文件都不会保留已经过期的键。 [📖](marginnote3app://note/75C3DAB0-0DAC-4D6D-AC65-A12695658BF1)
                - 当一个过期键被删除之后,程序会追加一条新的 DEL 命令到现有 AOF 文件末尾。 [📖](marginnote3app://note/3211F107-A065-45BA-B391-D8F300695813)
                - 当主节点删除一个过期键之后,它会显式地发送一条 DEL 命令到所有附属节点。 [📖](marginnote3app://note/2BD7BB8B-BD51-4EBA-BF83-F0BC469DE690)
                - 附属节点即使发现过期键,也不会自作主张地删除它,而是等待主节点发来 DEL 命令, 这样可以保证主节点和附属节点的数据总是一致的。 [📖](marginnote3app://note/40C81F23-B422-4288-9028-AA3291032EEA)
                - 数据库的 dict 字典和 expires 字典的扩展策略和普通字典一样。它们的收缩策略是:当节点的填充百分比不足 10% 时,将可用节点数量减少至大于等于当前已用节点数量。 [📖](marginnote3app://note/5B7AEDC8-3FB5-41B4-BB5A-6BA207F26998)
                - 数据库的键总是一个字符串对象,而值可以是任意一种 Redis 数据类型,包括字符串、哈希、集合、列表和有序集。 [📖](marginnote3app://note/A91836DC-6B6C-4E1C-BC4C-DD64B112238D)
                - 数据库主要由 dict 和 expires 两个字典构成,其中 dict 保存键值对,而 expires 则保存键的过期时间。 [📖](marginnote3app://note/0B357FED-04C6-4EE1-80FE-AA9C2635C6B8)
        - RDB [📖](marginnote3app://note/015C18EA-2B4F-4E61-B7AA-12F5C19031DA)
            - 保存 [📖](marginnote3app://note/E48D300B-B149-499A-9B28-64414B2EBC31)
                - Redis 分别提供了 RDB 和 AOF 两种持久化模式 [📖](marginnote3app://note/D56FC39B-5B7E-4757-A8D3-54C369A87910)
                - RDB 程序将当前内存中的数据库快照保存到磁盘文件中,在 Redis 重启动时,RDB 程序可以通过载入 RDB 文件来还原数据库的状态 [📖](marginnote3app://note/D5921AF9-5159-4756-AA40-82CE7A38F3A6)
            - SAVE 、 BGSAVE 、 AOF 写入和 BGREWRITEAOF [📖](marginnote3app://note/4235D6AA-6708-4D57-B7E1-9D5C750DDC2D)
                - 当 SAVE 执行时,Redis 服务器是阻塞的 [📖](marginnote3app://note/6D84FAFB-45FE-466E-854E-8428BEBBB638)
            - 载入 [📖](marginnote3app://note/B6CF2262-9437-455F-9DA9-FE1C83AE7932)
            - RDB 文件结构 [📖](marginnote3app://note/AA90999F-95BD-4CAB-9B7C-B7850E1CF704)
            - 小结 [📖](marginnote3app://note/B64F112A-7BFF-43B7-8A52-ECF72228467F)
        - AOF [📖](marginnote3app://note/D37C91FB-CED8-44FF-ADDD-54FDF216555B)
            - AOF 命令同步 [📖](marginnote3app://note/B990D303-7C19-4086-8ACE-55C4F914C6E3)
            - 命令传播 [📖](marginnote3app://note/32A72ED3-59B7-4FE0-8E63-9B83E905C95F)
            - 缓存追加 [📖](marginnote3app://note/4E820C36-7D12-4CF3-8130-B1799FEED768)
            - 文件写入和保存 [📖](marginnote3app://note/82C3EAF2-CCF0-4A80-A346-948D572B5ECA)
            - AOF 保存模式 [📖](marginnote3app://note/56A96037-FAA3-44C5-9AC0-637DDD119D2F)
                - Redis 目前支持三种 AOF 保存模式 [📖](marginnote3app://note/865AA453-E017-4BC1-9C85-33BE1226AED9)
                    - 1. AOF_FSYNC_NO :不保存。 [📖](marginnote3app://note/D5421E8D-9765-4AA8-8F91-0E604C6AE60C)
                    - 2. AOF_FSYNC_EVERYSEC :每一秒钟保存一次。 [📖](marginnote3app://note/C72DB230-8AB0-4E24-8F09-EED73BFCAF32)
                    - 3. AOF_FSYNC_ALWAYS :每执行一个命令保存一次。 [📖](marginnote3app://note/2A291A84-28F9-449A-ADA2-FD42B110D133)
            - AOF 保存模式对性能和安全性的影响 [📖](marginnote3app://note/10320DA2-D917-40B6-A693-E12B16964F93)
            - AOF 文件的读取和数据还原 [📖](marginnote3app://note/E4110A57-C7E5-429D-9ACC-03FE50008997)
            - AOF 重写 [📖](marginnote3app://note/131B746D-8BEC-47B5-9C42-EB328822544D)
            - AOF 重写的实现 [📖](marginnote3app://note/5A614566-5823-4703-A0E7-60C625D85782)
            - AOF 后台重写 [📖](marginnote3app://note/72CB8D65-00A2-4219-88E4-B1EDF450BEF0)
            - AOF 后台重写的触发条件 [📖](marginnote3app://note/820014E2-0EF9-4388-8E99-5BB60A9E0B70)
            - 小结 [📖](marginnote3app://note/D51DC6B4-4310-4C3D-A6FC-C36E658D8A4D)
            - rdbSave 会将数据库数据保存到 RDB 文件,并在保存完成之前阻塞调用者。 [📖](marginnote3app://note/73EC7E91-C180-43AD-B2EF-F1D5668479AD)
            - SAVE 命令直接调用 rdbSave ,阻塞 Redis 主进程;BGSAVE 用子进程调用 rdbSave , 主进程仍可继续处理命令请求。 [📖](marginnote3app://note/8578206C-413D-4348-8E49-FF6B837CD22F)
            - SAVE 执行期间,AOF 写入可以在后台线程进行,BGREWRITEAOF 可以在子进程进行,所以这三种操作可以同时进行。 [📖](marginnote3app://note/5530CEA6-B96F-4E67-928E-6036ED0AC26E)
            - 为了避免产生竞争条件,BGSAVE 执行时,SAVE 命令不能执行。 [📖](marginnote3app://note/9F294525-5E72-4B2E-BEB2-B63B26115EC4)
            - RDB 将数据库的快照(snapshot)以二进制的方式保存到磁盘中。 [📖](marginnote3app://note/4BC0B166-AD18-44A1-A8D3-3C7A51057C51)
            - AOF 则以协议文本的方式,将所有对数据库进行过写入的命令(及其参数)记录到 AOF 文件,以此达到记录数据库状态的目的。 [📖](marginnote3app://note/087C71BF-3095-4FA6-BABA-C98EF07209F2)
        - 事件 [📖](marginnote3app://note/C5B060B9-320C-43F7-AA14-CB375B453D54)
            - 文件事件 [📖](marginnote3app://note/95D6BCD5-8821-41F6-8A61-249602D8335E)
            - 时间事件 [📖](marginnote3app://note/BEBC9880-5A26-4844-B1F3-2314470F2CFB)
            - 时间事件应用实例：服务器常规操作 [📖](marginnote3app://note/1E4F2E7B-E59C-4DA8-BAE5-76E7B589986C)
                - 时间事件记录着那些要在指定时间点运行的事件,多个时间事件以无序链表的形式保存在服务器状态中。 [📖](marginnote3app://note/965FDE63-F8ED-426E-9F54-B4BD00BFD0FD)
            - 事件的执行与调度 [📖](marginnote3app://note/3B7A8278-79FC-4BB3-9E48-3C9455A7EEB1)
            - 小结 [📖](marginnote3app://note/E368C96F-AC52-46B7-903A-60A2F2B95BAC)
        - 服务器与客户端 [📖](marginnote3app://note/52103871-F4D6-4217-870B-E4184205917D)
            - 初始化服务器 [📖](marginnote3app://note/94E1D107-22D3-41D8-B977-E6BC37B0E26C)
            - 客户端连接到服务器 [📖](marginnote3app://note/18E28D5C-DA4B-489E-AB05-EA11D0AFA9A7)
            - 命令的请求、处理和结果返回 [📖](marginnote3app://note/D3219AF7-1FA9-470E-8B01-E6C08D5112DD)
            - 命令请求实例： SET 的执行过程 [📖](marginnote3app://note/EE33F793-1386-4301-AEA0-C4F6391084C3)
            - 小结 [📖](marginnote3app://note/4C30064D-EB18-4AD2-B159-9922E28F8766)
            - Redis 的事件分为时间事件和文件事件两类。 [📖](marginnote3app://note/34F6BB17-5A39-4E39-96AF-6570B60541AC)
            - 文件事件分为读事件和写事件两类:读事件实现了命令请求的接收,写事件实现了命令结果的返回。 [📖](marginnote3app://note/3B4D2D2A-1BF9-49CC-A42E-934C4C69E516)
            - 时间事件分为单次执行事件和循环执行事件,服务器常规操作 serverCron 就是循环事件。 [📖](marginnote3app://note/CBF97751-6F83-4969-9A33-12E50217431B)
            - 文件事件和时间事件之间是合作关系:一种事件会等待另一种事件完成之后再执行,不会出现抢占情况。 [📖](marginnote3app://note/58F4011B-A62C-4B0C-9F84-7E06B01C0E1A)
            - 时间事件的实际执行时间通常会比预定时间晚一些。 [📖](marginnote3app://note/55923280-9EB7-4E25-BCA4-C88097D0A033)
    - 关于 [📖](marginnote3app://note/C99A2E5C-8E01-43B6-96BF-4F99DA6DB666)
    - 通过捐款支持本书 [📖](marginnote3app://note/13BD83BE-5C6A-4E1A-BB4D-E9C8BA3FFD2E)

# Backlinks
## [May 2nd, 2022](<May 2nd, 2022.md>)
- [redis](<redis.md>)

