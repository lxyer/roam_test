- 什么是[上下文切换](<上下文切换.md>)?
    - 线程只在分配的时间片内占用处理器，当一个线程分配的时间片用完了，或者自身原因被迫暂停运行的时候，就会有另外一个线程来占用这个处理器，这种一个线程让出处理器使用权，另外一个线程获取处理器使用权的过程就叫做上下文切换。一个线程让出处理器使用权，就是“切出”；另外一个线程获取处理器使用权,就是“切入”.在这个切入切出的过程中，操作系统会保存和恢复相关的进度信息，这个进度信息就是我们常说的“上下文”，上下文中一般包含了寄存器的存储内容以及程序计数器存储的指令内容。

# Backlinks
## [CAS原理](<CAS原理.md>)
- 执行过程是这样：它包含 3 个参数 CAS（V，E，N），V表示要更新变量的值，E表示预期值，N表示新值。仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他[线程](<线程.md>)完

- 执行过程是这样：它包含 3 个参数 CAS（V，E，N），V表示要更新变量的值，E表示预期值，N表示新值。仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他[线程](<线程.md>)完成更新，则当前[线程](<线程.md>)则

## [CV](<CV.md>)
- [线程](<线程.md>)共

- [堆](<堆.md>)（Heap）：[线程](<线程.md>)共

- [方法区](<方法区.md>)（Method Area）：[线程](<线程.md>)共

- [线程](<线程.md>)私

- [方法栈](<方法栈.md>)（JVM Stack）：[线程](<线程.md>)私

- [本地方法栈](<本地方法栈.md>)（Native Method Stack）：[线程](<线程.md>)私

- [程序计数器](<程序计数器.md>)（Program Counter Register）：[线程](<线程.md>)私

- [程序计数器](<程序计数器.md>)（Program Counter Register）：[线程](<线程.md>)私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前[线程](<线程.md>)所

- **Memcached****是多[线程](<线程.md>)，

- **Memcached通过使用多个内核**实现多[线程](<线程.md>)体

## [IO](<IO.md>)
- ____ — via [15分钟读懂进程[线程](<线程.md>)、

- 阻塞调用是指调用结果返回之前，当前[线程](<线程.md>)会

- 阻塞调用是指调用结果返回之前，当前[线程](<线程.md>)会被挂起。调用[线程](<线程.md>)只

- 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前[线程](<线程.md>)

- 并行：当系统有一个以上CPU时，则[线程](<线程.md>)的

- 并行：当系统有一个以上CPU时，则[线程](<线程.md>)的操作有可能非并发。当一个CPU执行一个[线程](<线程.md>)时

- 并行：当系统有一个以上CPU时，则[线程](<线程.md>)的操作有可能非并发。当一个CPU执行一个[线程](<线程.md>)时，另一个CPU可以执行另一个[线程](<线程.md>)，

- 并行：当系统有一个以上CPU时，则[线程](<线程.md>)的操作有可能非并发。当一个CPU执行一个[线程](<线程.md>)时，另一个CPU可以执行另一个[线程](<线程.md>)，两个[线程](<线程.md>)互

- 异步和多[线程](<线程.md>)有

- 其实，异步是目的，而多[线程](<线程.md>)是

## [JVM](<JVM.md>)
- [Serial收集器](<Serial收集器.md>)的老年代版本，同样是一个单[线程](<线程.md>)收

- 保证在多[线程](<线程.md>)环

- 保证在多[线程](<线程.md>)环境中程序可以连续执行。存放当前[线程](<线程.md>)执

- 新生代单[线程](<线程.md>)收

- 新生代单[线程](<线程.md>)收集器，标记和清理都是单[线程](<线程.md>)，

- ParNew收集器其实就是[Serial收集器](<Serial收集器.md>)的多[线程](<线程.md>)版

- ParNew收集器其实就是[Serial收集器](<Serial收集器.md>)的多[线程](<线程.md>)版本，除了使用多条[线程](<线程.md>)进

- ParNew收集器其实就是[Serial收集器](<Serial收集器.md>)的多[线程](<线程.md>)版本，除了使用多条[线程](<线程.md>)进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的也是复制算法。它是Server模式下的虚拟机首选的新生代收集器，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。CMS收集器是一款几乎可以认为有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集[线程](<线程.md>)与

- ParNew收集器其实就是[Serial收集器](<Serial收集器.md>)的多[线程](<线程.md>)版本，除了使用多条[线程](<线程.md>)进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的也是复制算法。它是Server模式下的虚拟机首选的新生代收集器，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。CMS收集器是一款几乎可以认为有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集[线程](<线程.md>)与用户[线程](<线程.md>)基

- ParNew收集器其实就是[Serial收集器](<Serial收集器.md>)的多[线程](<线程.md>)版本，除了使用多条[线程](<线程.md>)进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的也是复制算法。它是Server模式下的虚拟机首选的新生代收集器，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。CMS收集器是一款几乎可以认为有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集[线程](<线程.md>)与用户[线程](<线程.md>)基本上同时工作。ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于[线程](<线程.md>)交

- ParNew收集器其实就是[Serial收集器](<Serial收集器.md>)的多[线程](<线程.md>)版本，除了使用多条[线程](<线程.md>)进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的也是复制算法。它是Server模式下的虚拟机首选的新生代收集器，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。CMS收集器是一款几乎可以认为有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集[线程](<线程.md>)与用户[线程](<线程.md>)基本上同时工作。ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于[线程](<线程.md>)交互的开销，该收集器在两个CPU的环境中都不能百分之百保证可以超越Serial收集器。当然，随着可用CPU数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集[线程](<线程.md>)数

- ParNew收集器其实就是[Serial收集器](<Serial收集器.md>)的多[线程](<线程.md>)版本，除了使用多条[线程](<线程.md>)进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的也是复制算法。它是Server模式下的虚拟机首选的新生代收集器，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。CMS收集器是一款几乎可以认为有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集[线程](<线程.md>)与用户[线程](<线程.md>)基本上同时工作。ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于[线程](<线程.md>)交互的开销，该收集器在两个CPU的环境中都不能百分之百保证可以超越Serial收集器。当然，随着可用CPU数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集[线程](<线程.md>)数与CPU数量相同，在CPU数量非常多的情况下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的[线程](<线程.md>)数

- Parallel Scavenge收集器也是一个新生代收集器，也是用[复制算法](<复制算法.md>)的收集器，也是并行的多[线程](<线程.md>)收

- Parallel Scavenge收集器也是一个新生代收集器，也是用[复制算法](<复制算法.md>)的收集器，也是并行的多[线程](<线程.md>)收集器，介绍这个收集器主要还是介绍吞吐量的概念。CMS等收集器的关注点是尽可能缩短垃圾收集时用户[线程](<线程.md>)的

- Parallel Scavenge收集器的老年代版本，使用多[线程](<线程.md>)和

- 无法处理浮动垃圾，因为在并发清理阶段用户[线程](<线程.md>)还

- 无法处理浮动垃圾，因为在并发清理阶段用户[线程](<线程.md>)还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户[线程](<线程.md>)并

- (1). 并行和并发。使用多个CPU来缩短Stop The World停顿时间，与用户[线程](<线程.md>)并

- The World停顿时间，与用户[线程](<线程.md>)并

- [jconsole](<jconsole.md>)：用于对 JVM 中的内存、[线程](<线程.md>)和

- [jvisualvm](<jvisualvm.md>)： JDK 自带的全能分析工具，可以分析：内存快照、[线程](<线程.md>)快

## [July 27th, 2020](<July 27th, 2020.md>)
- 首先需要理解[线程](<线程.md>)安

- 内存可见控制的是[线程](<线程.md>)执

- 内存可见控制的是[线程](<线程.md>)执行结果在内存中对其它[线程](<线程.md>)的

- [synchronized](<synchronized.md>)还会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的[线程](<线程.md>)的

- [synchronized](<synchronized.md>)还会创建一个内存屏障，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的[线程](<线程.md>)的所有操作，都[happens-before](<happens-before.md>)于随后获得这个锁的[线程](<线程.md>)的

- volatile本质是在告诉jvm当前变量在[寄存器](<寄存器.md>)（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前[线程](<线程.md>)可

- volatile本质是在告诉jvm当前变量在[寄存器](<寄存器.md>)（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前[线程](<线程.md>)可以访问该变量，其他[线程](<线程.md>)被

- volatile不会造成[线程](<线程.md>)的

- volatile不会造成[线程](<线程.md>)的阻塞；synchronized可能会造成[线程](<线程.md>)的

## [July 7th, 2020](<July 7th, 2020.md>)
- 5.6版本之前，MySQL只支持单[线程](<线程.md>)复

## [June 22nd, 2020](<June 22nd, 2020.md>)
- 使用synchronized修饰的对象或者代码段,只能由一个[线程](<线程.md>)执

## [MySQL](<MySQL.md>)
- MySQL提供了一个加全局读锁的方法，命令是 Flush tables with read lock ([FTWRL](<FTWRL.md>))。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他[线程](<线程.md>)的

## [October 24th, 2020](<October 24th, 2020.md>)
- 单[线程](<线程.md>)

## [Redis](<Redis.md>)
- [Redis](<Redis.md>)的[线程](<线程.md>)模

- [Redis](<Redis.md>) 内部使用文件事件处理器 file event handler，这个文件事件处理器是「单[线程](<线程.md>)」

- [Redis](<Redis.md>) 内部使用文件事件处理器 file event handler，这个文件事件处理器是「单[线程](<线程.md>)」的，所以 [Redis](<Redis.md>) 才叫做「单[线程](<线程.md>)的

- Master写内存快照，save命令调度rdbSave函数，会阻塞主[线程](<线程.md>)的

## [单例](<单例.md>)
- 能避免多[线程](<线程.md>)同

