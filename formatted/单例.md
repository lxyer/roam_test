- **[参考](<参考.md>):**
    - **[关键词](<关键词.md>):** #[永久笔记](<永久笔记.md>)
        - 
- 常见的两种方式
    - 将构造器私有,通过public导出静态域
    - public的静态final成员变量
    - ```public class Singleton{
    public static final Singleton instance = new Singleton();
    private Singleton(){
    ......
    }
}```
    - 缺点:可以通过[反射](<反射.md>)改变构造器的私有属性,创建多个实例,需要进一步的做逻辑判断不允许创建第二个实例
    - 

- 另一种方式:使用public导出的静态方法
    - ```clojure
class Singleton{
    private static final Singleton instance = new Singleton();
    public static Singleton getInstance(){
        return instance;
    }
    private Singleton(){};
}```
    - 同样存在使用反射进行攻击的问题,还有一个问题就是,在序列化的时候,仅仅在声名中加上“implement Serializable”是不够的。为了维护并保证Singleton，必须声名所有的实例都是[transient](<transient.md>)，并提供一个[readResolve](<readResolve.md>)方法。否则的话每次反序列化的时候都会创建一个新的实例，这个时候要加入以下代码：
        - ```clojure
// readResolve method to preserve singleton property
private Object readResolve() {
    // Return the one true Elvis and let the garbage collector
    // take care of the Elvis impersonator
    return INSTANCE;
}```
- [最佳实践](<最佳实践.md>)
    - 使用[枚举](<枚举.md>)元素的方式创建单例最可靠也最安全
        - 这种方式也是[《Effective Java》](<《Effective Java》.md>)的作者[Josh Bloch](<Josh Bloch.md>)推荐的#[Reading list](<Reading list.md>)
        - 能避免多[线程](<线程.md>)同步问题，而且还能防止反序列化**重新创建新的对象**(由枚举保证)
        - ```clojure
class Resource{
}

public enum SomeThing {
    INSTANCE;
    private Resource instance;
    SomeThing() {
        instance = new Resource();
    }
    public Resource getInstance() {
        return instance;
    }
}```

# Backlinks
## [July 30th, 2020](<July 30th, 2020.md>)
- [单例](<单例.md>)

