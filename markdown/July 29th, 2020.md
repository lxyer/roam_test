- [[李一诺]]的平衡车到了,[[我爸]]说她玩了一会就不爱玩了
- 进入到我的[[知乎专栏]],发现很多投稿了,我通过了还多文章
- 第一次去地铁站下的美食广场吃午餐
- [[Spring]][[自动注入]]([[DI]]) #Java
    - 三种方式
        - 构造器注入
            - ```clojure
private DependencyA dependencyA;
private DependencyB dependencyB;
private DependencyC dependencyC;

@Autowiredpublic DI(DependencyA dependencyA, DependencyB dependencyB, DependencyC dependencyC) {
    this.dependencyA = dependencyA;
    this.dependencyB = dependencyB;
    this.dependencyC = dependencyC;```
        - Setter注入
            - ```clojure
private DependencyA dependencyA;
private DependencyB dependencyB;
private DependencyC dependencyC;

@Autowiredpublic void setDependencyA(DependencyA dependencyA) {
    this.dependencyA = dependencyA;
}

@Autowiredpublic void setDependencyB(DependencyB dependencyB) {
    this.dependencyB = dependencyB;
}

@Autowiredpublic void setDependencyC(DependencyC dependencyC) {
    this.dependencyC = dependencyC;
}```
        - Field 注入
            - ```clojure
@Autowired
private DependencyA dependencyA;

@Autowired
private DependencyB dependencyB;

@Autowired
private DependencyC dependencyC;```
    - ### 问题是什么
        - 正如你所见，[[Field注入]]看起来非常好，够简洁，并且也没有样板式的代码(为了实现通用和简单的任务而重复的代码)。代码通俗易懂。你的类可以专注于业务而不被[[依赖注入]]所污染。你只需要把@Autowired扔到变量之上就好了，不需要特殊的构造器或者set方法，依赖注入容器会提供你所需的依赖。Java本身就非常繁重，所以要尽可能的让你的代码简洁。
        - [[单一职责侵入原则]]
            - 添加依赖是很简单的，可能过于简单了。添加六个、十个甚至一堆依赖一点也没有困难。当你使用构造器方式注入，到了某个特定的点，构造器中的参数变得太多以至于很明显地发现something is wrong。拥有太多的依赖通常意味着你的类要承担更多的责任。明显违背了单一职责原则（SRP：Single responsibility principle）。
        - [[依赖隐藏]]
            - 使用依赖注入容器意味着类不再对依赖负责，获取依赖的职责从类中抽离出来，依赖容器会帮你装配。当类不再为依赖负责，它应该更明确的使用公有的接口方法或构造器，使用这种方式能很清晰的了解类需要什么，也能明确它是可选的(setter注入)还是强制的(构造器注入)。
        - 依赖注入容器耦合
            - 依赖注入框架的核心思想之一就是受容器管理的类不应该去依赖容器所使用的依赖。换句话说，这个类应该是一个简单的POJO(Plain Ordinary Java Object)能够被单独实例化并且你也能为它提供它所需的依赖。只有这样，你才能在单元测试中实例化这个类而不必去启动依赖注入容器，实现测试分离(启动容器更多是集成测试)。
        - 不变性
            - 不像构造器注入，Field注入不能有效地用来指定依赖
    - 构造器注入 VS Setter注入
        - Setter
            - Setter应该被用来注入可变的依赖。当没有提供依赖时，这个类也应该能够运转。当实例化对象后，这些依赖也能随时改变。其实也视情况而变,有时，一个不变的对象是理想状态。有时，最好是能在运行期间改变对象的属性。
        - 构造器
            - 构造器对注入强制性的的依赖是好的。对象需要这些依赖才能正常运转，通过构造器提供这些依赖就能保证对象初始化后就能被使用。使用构造器注入的一个可能的影响就是循环依赖。
    - 结论
        - 如果注入的属性是必选的属性，则通过构造器注入。
        - 如果注入的属性是可选的属性，则通过setter方法注入。
        - 至于field注入，不建议使用。
    - IDEA在设置中把Field injection warning的Severity级别调高,在代码中就可以提示修改意见了
- [[卡片盒笔记法]] #slip-box
- {{{[[DONE]]}}}} [[Spring Shell]]
- 学习了[[YouTube]]上[[Shu Omi]]的关于如何使用[[Roam Research]]实践[[卡片盒笔记法]]的视频,并做了笔记,收获很大
- 
