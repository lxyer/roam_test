- [[延迟任务]]的使用场景
    - 红包24小时未查收,金额进行退还
    - 每个月的账单日,给用户发送账单
    - 订单下单后30分钟没有支付,系统自动取消订单
- [[延迟任务]]和[[定时任务]]的区别
    - [[延迟任务]]不需要对一个任务使用短时间间隔的定时任务不同的去执行,到了需要执行的时间执行一次即可
- 实现思路
    - [[JDK]]实现
        - [[DelayQueue]]
        - [[ScheduledExecutorService]]
    - 第三方工具的[[延迟任务]]
        - [[Redis]]
            - 借助 [[zset]] 数据类型，把[[延迟任务]]存储在此数据集合中，然后在开启一个无线循环查询当前时间的所有任务进行消费
            -  [[[[Redis]] ]]服务器端是不开启键空间通知的，需要我们通过 config set notify-keyspace-events Ex 的命令手动开启，开启键空间通知后，我们就可以拿到每个键值过期的事件，我们利用这个机制实现了给每个人开启一个定时任务的功能
        - [[Netty]]
            - 工具类 [[HashedWheelTimer ]]来实现[[延迟任务]]
                - HashedWheelTimer 是使用定时轮实现的，[[定时轮]]其实就是一种环型的数据结构
        - [[MQ]]
            - [[RabbitMQ]]
                - 通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能
                - 使用 [[RabbitMQ]]-delayed-message-exchange 插件实现延迟功能
    - 无限循环实现[[延迟任务]]
        - 使用一个map储存定时任务名称和需要执行的时间戳
        - 用一个死循环去判断需要执行的时间戳是否小于当前时间的时间戳,是的话执行任务
        - map中remove这个任务
    - 使用[[Spring]][[定时任务]]
    - [[Quartz ]]实现[[延迟任务]]
- 总结
    - 手动无线循环；
    - ScheduledExecutorService；
    - DelayQueue；
    - [[Redis]] zset 数据判断的方式；
    - [[Redis]] 键空间通知的方式；
    - Netty 提供的 HashedWheelTimer 工具类；
    - RabbitMQ 死信队列；
    - RabbitMQ 延迟消息插件 rabbitmq-delayed-message-exchange；
    - Spring Scheduled；
    - Quartz。
